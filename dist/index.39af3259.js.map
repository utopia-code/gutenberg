{"mappings":"iEAOiBA,E,KAQG,oBAAXC,QAAyBA,OARjBD,EAQgC,WAG7C,GAAsB,oBAAXC,OACP,OAAO,KAIX,IAAIC,EAAgC,oBAAVD,QAAyBA,OAAOE,MAAQA,KAC5DF,OACe,oBAARG,MAAuBA,KAAKD,MAAQA,KACvCC,KACAC,SAAS,cAATA,GAINC,EAAwBJ,EAAaI,uBACrCJ,EAAaK,0BACbL,EAAaM,6BACb,SAAUC,GACN,OAAOP,EAAaQ,WAAWD,EAAI,GACvC,EAEAE,EAAuBT,EAAaS,sBACpCT,EAAaU,yBACbV,EAAaW,4BACb,SAAUC,GACNZ,EAAaa,aAAaD,EAC9B,EAQJ,SAASE,EAAeC,EAAUC,GAC9B,IAAIC,EAAeC,OAAOC,UAAUC,SAASC,KAAKN,GAC9CO,EAAqB,mBAAqBL,GACtC,sBAAwBA,GACxB,4BAA8BA,GAC9B,oBAAsBA,GACtB,oBAAuBM,QAAUR,aAAoBQ,QACrD,oBAAuBC,UAAYT,aAAoBS,SAE3DC,EAAI,EAAGC,EAAIX,EAASY,OACxB,GAAIL,EACA,KAAOG,EAAIC,EAAGD,IACVT,EAASD,EAASU,SAGtBT,EAASD,EAEjB,CAOA,SAASa,EAAeC,GACpB,IAAKA,EAAQC,sBACT,MAAO,CACHC,MAAOF,EAAQG,YACfC,OAAQJ,EAAQK,cAIxB,IAAIC,EAAON,EAAQC,wBACnB,MAAO,CACHC,MAAO9B,KAAKmC,MAAMD,EAAKJ,OACvBE,OAAQhC,KAAKmC,MAAMD,EAAKF,QAEhC,CAQA,SAASI,EAASR,EAASS,GACvBpB,OAAOqB,KAAKD,GAAOE,SAAQ,SAASC,GAChCZ,EAAQS,MAAMG,GAAOH,EAAMG,EAC/B,GACJ,CAUA,IAAIC,EAAe,SAASb,EAASb,GAEjC,IAAI2B,EAAsC,EAM1C,SAASC,IACL,IAKInB,EAAGC,EALHmB,EAAI,GACRC,KAAKC,IAAM,SAASC,GAChBH,EAAEI,KAAKD,EACX,EAGAF,KAAKzB,KAAO,SAAS6B,GACjB,IAAKzB,EAAI,EAAGC,EAAImB,EAAElB,OAAQF,EAAIC,EAAGD,IAC7BoB,EAAEpB,GAAGJ,KAAKyB,KAAMI,EAExB,EAEAJ,KAAKK,OAAS,SAASH,GACnB,IAAII,EAAW,GACf,IAAI3B,EAAI,EAAGC,EAAImB,EAAElB,OAAQF,EAAIC,EAAGD,IACzBoB,EAAEpB,KAAOuB,GAAII,EAASH,KAAKJ,EAAEpB,IAEpCoB,EAAIO,CACR,EAEAN,KAAKnB,OAAS,WACV,OAAOkB,EAAElB,MACb,CACJ,CAOA,SAAS0B,EAAkBxB,EAASyB,GAChC,GAAKzB,EACL,GAAIA,EAAQ0B,gBACR1B,EAAQ0B,gBAAgBR,IAAIO,OADhC,CAKAzB,EAAQ0B,gBAAkB,IAAIX,EAC9Bf,EAAQ0B,gBAAgBR,IAAIO,GAE5BzB,EAAQ2B,aAAeC,SAASC,cAAc,OAC9C7B,EAAQ2B,aAAaG,IAAM,MAC3B9B,EAAQ2B,aAAaI,UAAY,gBAEjC,IAAItB,EAAQ,CACRuB,cAAe,OACfC,SAAU,WACVC,KAAM,MACNC,IAAK,MACLC,MAAO,MACPC,OAAQ,MACRC,SAAU,SACVC,OAAQ,KACRC,WAAY,SACZC,SAAU,QAEVC,EAAa,CACbT,SAAU,WACVC,KAAM,MACNC,IAAK,MACLQ,WAAY,MAGhBnC,EAASR,EAAQ2B,aAAclB,GAE/B,IAAImC,EAAShB,SAASC,cAAc,OACpCe,EAAOb,UAAY,uBACnBvB,EAASoC,EAAQnC,GAEjB,IAAIoC,EAAcjB,SAASC,cAAc,OACzCrB,EAASqC,EAAaH,GACtBE,EAAOE,YAAYD,GAEnB,IAAIE,EAASnB,SAASC,cAAc,OACpCkB,EAAOhB,UAAY,uBACnBvB,EAASuC,EAAQtC,GAEjB,IAAIuC,EAAcpB,SAASC,cAAc,OACzCrB,EAASwC,EAAaN,GACtBlC,EAASwC,EAAa,CAAE9C,MAAO,OAAQE,OAAQ,SAC/C2C,EAAOD,YAAYE,GAEnBhD,EAAQ2B,aAAamB,YAAYF,GACjC5C,EAAQ2B,aAAamB,YAAYC,GACjC/C,EAAQ8C,YAAY9C,EAAQ2B,cAE5B,IAAIsB,EAAgB/E,OAAOgF,iBAAiBlD,GACxCiC,EAAWgB,EAAgBA,EAAcE,iBAAiB,YAAc,KACxE,aAAelB,GAAY,aAAeA,GAAY,UAAYA,GAAY,WAAaA,IAC3FjC,EAAQS,MAAMwB,SAAW,YAG7B,IAAImB,GAAQ,EAGRC,EAAQ,EACRC,EAAOvD,EAAeC,GACtBuD,EAAY,EACZC,EAAa,EACbC,GAAqB,EACzB3C,EAAsC,EAEtC,IAcI4C,EAAQ,WAER,GAAID,EAAoB,CAEpB,GADwC,IAAxBzD,EAAQG,aAA8C,IAAzBH,EAAQK,aAUjD,YAPKS,IACDA,EAAsCvC,GAAsB,WACxDuC,EAAsC,EACtC4C,GACJ,MAMJD,GAAqB,CAE7B,CAhCoB,IAChBvD,EACAE,EADAF,EAAQF,EAAQG,YAChBC,EAASJ,EAAQK,aAErBwC,EAAYpC,MAAMP,MAAQA,EAAS,GAAM,KACzC2C,EAAYpC,MAAML,OAASA,EAAU,GAAM,KAE3CwC,EAAOe,WAAazD,EAAQ,GAC5B0C,EAAOgB,UAAYxD,EAAS,GAE5B2C,EAAOY,WAAazD,EAAQ,GAC5B6C,EAAOa,UAAYxD,EAAS,EAwBhC,EACAJ,EAAQ2B,aAAakC,YAAcH,EAEnC,IAAII,EAAY,WACZT,EAAQ,EAEHD,IAELG,EAAYD,EAAKpD,MACjBsD,EAAaF,EAAKlD,OAEdJ,EAAQ0B,iBACR1B,EAAQ0B,gBAAgBlC,KAAK8D,GAErC,EAEIS,EAAW,WACXT,EAAOvD,EAAeC,IACtBoD,EAAQE,EAAKpD,QAAUqD,GAAaD,EAAKlD,SAAWoD,KAEtCH,IACVA,EAAQ9E,EAAsBuF,IAGlCJ,GACJ,EAEIM,EAAW,SAASC,EAAIC,EAAMC,GAC1BF,EAAGG,YACHH,EAAGG,YAAY,KAAOF,EAAMC,GAE5BF,EAAGI,iBAAiBH,EAAMC,EAElC,EAEAH,EAASpB,EAAQ,SAAUmB,GAC3BC,EAASjB,EAAQ,SAAUgB,GAG3BjD,EAAsCvC,GAAsB,WACxDuC,EAAsC,EACtC4C,GACJ,GAhJA,CAiJJ,CAEAzE,EAAee,GAAS,SAASsE,GAC7B9C,EAAkB8C,EAAMnF,EAC5B,IAEA8B,KAAKsD,OAAS,SAASpD,GAEdL,IACDlC,EAAqBkC,GACrBA,EAAsC,GAE1CD,EAAa0D,OAAOvE,EAASmB,EACjC,EAEAF,KAAKyC,MAAQ,WACT1D,EAAQ2B,aAAakC,aACzB,CACJ,EAyBA,GAvBAhD,EAAa6C,MAAQ,SAAS1D,GAC1Bf,EAAee,GAAS,SAASsE,GAC7BA,EAAK3C,aAAakC,aACtB,GACJ,EAEAhD,EAAa0D,OAAS,SAASvE,EAASmB,GACpClC,EAAee,GAAS,SAASsE,GACxBA,IACFA,EAAK5C,iBAAiC,mBAAPP,IAC9BmD,EAAK5C,gBAAgBJ,OAAOH,GACzBmD,EAAK5C,gBAAgB5B,WAExBwE,EAAK3C,eACD2C,EAAKE,SAASF,EAAK3C,eACnB2C,EAAKG,YAAYH,EAAK3C,qBAEnB2C,EAAK3C,oBACL2C,EAAK5C,iBAEpB,GACJ,EAEgC,oBAArBgD,iBAAkC,CACzC,IAAIC,EAAW,IAAID,kBAAiB,SAAUE,GAC1C,IAAK,IAAIhF,KAAKgF,EACV,GAAIA,EAAUC,eAAejF,GAEzB,IADA,IAAIkF,EAAQF,EAAUhF,GAAGmF,WAChBlF,EAAI,EAAGA,EAAIiF,EAAMhF,OAAQD,IAC1BiF,EAAMjF,GAAG8B,cACTd,EAAa6C,MAAMoB,EAAMjF,GAK7C,IAEA+B,SAASyC,iBAAiB,oBAAoB,SAAUW,GACpDL,EAASM,QAAQrD,SAASsD,KAAM,CAC5BC,WAAW,EACXC,SAAS,GAEjB,GACJ,CAEA,OAAOvE,CAEX,EAtW0B,mBAAXwE,QAAyBA,OAAOC,IACvCD,OAAOpH,GAEPsH,EAAiBtH;;;;;;;ACCrB,MAAMuH,EAAY,M,MAiBhBC,EAAA,iBAYAC,EAAA,CAmBFC,WAAA,EAIAC,cAAA,E,mBAsEqB,E,qBAON,wB,YAKF,a,cAOA,E,UAKL,G,MAgBJC,E,gBASA5E,KAAK6E,sBAGD7E,KAAC8E,QAAYC,uBACnB/E,KAAAgF,aAAAhF,KAAAiF,QAAAC,cAAAlF,KAAA8E,QAAAC,sBAEA,OAAA/E,KAAAgF,eAAAhF,KAAAgF,cAAA,KAK2ChF,KAAAgF,aAAa,CAAE,IAAAG,EAAcxE,SAAAC,cAAA,OAC7B,IAD6BuE,EAAAC,aAAA,gCACtEpF,KAAOiF,QAAApD,YAAiBsD,GAAiBnF,KAASiF,QAAII,YAAAF,KAAAtD,YAAA7B,KAAAiF,QAAAI,YAAErF,KAAAgF,aAAchF,KAAAiF,QAAAC,cAAA,yBAItE,GAAIlF,KAAK8E,QAAQQ,kBAAgB,CAC/B,IAAIC,EAAa5E,SAAK6E,iBAAmBxF,KAAA8E,QAAWQ,mBAWxD,GAVIC,EAAIE,MAAapH,UAAKqH,MAAWnH,KAAKgH,GACvCA,EAAA7F,SAAA,CAAAiG,EAAAC,KACHD,EAAApC,SAAAvD,KAAAiF,WAEAjF,KAAA2F,YAAA,KAMAJ,EAAA1G,OAAA,UAAAgH,MAAA,kDAEA,CAMM,mBAAsB7F,KAAA8E,QAAAJ,aAAA1E,KAAA8E,QAAAJ,WAAAoB,SAAA9F,KAAA8E,QAAAJ,aAAA,GAE1B,mBAAA1E,KAAA8E,QAAAH,gBAA0C3E,KAAA8E,QAAAH,cAAAmB,SAAA9F,KAAA8E,QAAAH,gBAAA,GAE1C3E,KAAK+F,mBAGL/F,KAAAgG,iBAEAhG,KAAKiG,iBAGLjG,KAAKkG,aAGPlG,KAAAmG,cAAA,CAEA,C,aAWElJ,OAAKmG,iBAAiB,SAASpD,KAAA,CAE/BoG,SAAK,EACLC,SAAK,IAKLpJ,OAAImG,iBAAe,SAAYpD,KAAA,CAG3BoG,SAAA,EAEFC,SAAA,I,aACOjD,iBAAc,SAAKoB,EAAiBxE,M,KACzC8E,QAAKpE,cAAe,oBAAAd,eACtB,IAACA,aAAAI,KAAAgF,aAAAhF,KAAAsG,aAAD,IAEK1G,aAAII,KAAA2F,UAA0B3F,KAACsG,a,aAMrCvC,GAED/D,KAAKuG,aAAAxC,E,CAWPiC,iBAEA,IAAAhG,KAAAwG,YAAA,CAIE,IAAIC,EAAOzG,KAAK0G,WAGhBD,EAAIE,aAAW/B,EAAgBgC,eAAiB5G,KAAM2F,WAAQzE,IAE9DuF,EAAAI,gBAAA7G,KAAA2F,UAAAmB,aACAL,EAAIM,gBAAgBN,EAAKE,aAAcF,EAAAI,gBAIzCJ,EAAAO,cAAAhH,KAAAgF,aAAA5F,aAQEqH,EAAIQ,aAAYjH,KAAAiF,QAAY/F,YAI5BuH,EAAIS,eAAgBjK,OAAKkK,YACzBnH,KAAIoH,2BA3BN,C,mCAkCMpH,KAAA0G,W,EAEFW,YAAWzC,EAAegC,eAAkB5G,KAAKiF,SAAAhE,K,cAC1CN,SAAa2G,gBAAc3E,WAAiBhC,SAAAsD,KAAAtB,U,iBACrC8D,EAAAc,YAAAd,EAAAS,e,EAEdM,aAAiB7G,SAAC2G,gBAAqB5E,YAAW/B,SAAYsD,KAAIvB,WAGpE+D,EAAA/B,WAAA1E,KAAA8E,QAAAJ,WACA+B,EAAA9B,cACE3E,KAAA8E,QAAAH,cACI,mBAAK8B,EAAqB/B,aAAI+B,EAAA/B,WAAAoB,SAAAW,EAAA/B,WAAA1E,KAAAiF,WAAA,GAEhC,mBAAsBwB,EAAG9B,gBAAe8B,EAAK9B,cAAiBmB,SAAAW,EAAA9B,cAAA3E,KAAAiF,WAAA,G,iBAC7CjF,KAAGyH,YAGpBhB,EAAO/B,WAAI+B,EAAeiB,iBACxBjB,EAAKkB,YAAalB,EAAAiB,eAAmBjB,EAAA/B,WACrC1E,KAAA4H,UAAY,GAEhB,oBAAA5H,KAAAyH,aAGMhB,EAAK9B,cAAe8B,EAAIoB,oBAC1BpB,EAAKkB,YAAalB,EAAKoB,kBAAkBpB,EAAA9B,cACzC3E,KAAA4H,UAAY,G,iBAIAnB,EAAA/B,W,EAEdmD,kBAAgBpB,EAAA9B,a,yBAYtB,OAAA3E,KAAA0G,WAAAM,cAAAhH,KAAA0G,WAAAQ,cAEA,C,uBAU0BT,EAAOzG,KAAC0G,WAAC,GAAAD,EAAAqB,kBAAArB,EAAAc,YAAA,CACjC,IAAIQ,EAAW,SAAW/H,KAAAgI,UAAA7K,KAAA8K,IAAA9K,KAAA+K,IAGxBzB,EAAKc,cAAAQ,EAAAtB,EAAAc,YAAAd,EAAAqB,mBAAA9H,KAAAgI,UAAA,SAAAhI,KAAAgI,UAAA,YAJ0B,C,sBAS7BhI,KAAM0G,WAAQyB,GAAA,E,uCAAyB1B,EAAAO,cAAAP,EAAAE,a,EAAcF,EAAKc,YAAWd,EAAA/B,W,EACvD+B,EAAK2B,eAAa3B,EAAA9B,c,aAA0B3E,KAAAgI,UAC1DK,GAAM5B,EAAAE,cACRF,EAAKkB,WAAA,EACLQ,EAAK,UACCE,GAAiB5B,EAAAkB,WAAiBlB,EAAKE,cAE3CF,EAAIkB,WACFU,EAAc5B,EAAAE,a,EAAC,iBAAoB3G,KAAAsI,yBAAA7B,EAAAE,cAAA0B,IAAAF,EAAA,qB,+BAEwBnB,cAAYqB,GAAY5B,EAAAM,iBAAAN,EAAAkB,WAAAlB,EAAAM,gBAAAwB,EACrFJ,EAAM,oBACVE,GAAA5B,EAAAE,eAEQF,EAAAkB,WAAAU,EAAA5B,EAAAE,aACNwB,EAAK,gBAIH1B,EAAAM,iBAAcyB,G,EAACb,WAAalB,EAAAM,gBAAawB,E,EAAE,oBAAoBA,EAAA9B,EAAAkB,YAAAa,GAC/D/B,EAAMkB,WAAAa,EAAAD,EACVJ,EAAA,mBAEc1B,EAAAE,aAAqBF,EAAAkB,YAAAU,IAAAF,EAAA,qBAAyB1B,EAAGkB,WAAWxK,KAAA+K,IAAA,EAAAzB,EAAAkB,YAC1ElB,EAAAkB,WAAcxK,KAAA8K,IAAAxB,EAAcI,gBAAOJ,EAAAkB,Y,EAACG,gBAAUrB,EAAAc,YAAYY,C,CAM5DM,UAAAN,GAQE,QAAI,IAAmBA,EAAvB,CAEA,IAAA3I,EAAY,CAERkJ,MAAA,GACAC,MAAA,IAGAlC,EAAAzG,KAAY0G,WAEhB,OAAKyB,GACH,IAAI,eACJ3I,EAAAkJ,MAAc,CAEV1H,SAAa,QAGfE,IAAAuF,EAAA/B,WAEOzD,KAAAwF,EAAOY,YAAaZ,EAAAe,aACvBvI,MAAAwH,EAASQ,cAEf,MAEA,IAAK,kBACHzH,EAAIkJ,MAAS,CACT1H,SAAC,QACPE,IAAA,OAEID,KAAAwF,EAAeY,YACnBjG,OAAcqF,EAAA9B,cAEV1F,MAAKwH,EAAAQ,cAIb,MAEA,uBAMM,wBACE,IAAC2B,EAAc5I,KAAI6I,cAAA,EAAApC,EAAAkB,WAAA,MACJnI,EAAAkJ,MAAdE,EAAc,CAEdE,UAAQF,GAEK,CAEb5H,SAAA,WAETE,IAAAuF,EAAAkB,WAEA1I,MAAAwH,EAAAQ,c,OAWIkB,G,IACE,e,6EAIS,C,OACD1B,EAACO,c,SACA,YAsBb,O,QAjBMpC,EAAKmE,OAAA,C,OACL,G,gCAGOA,OAAc,C,wBAEvB,G,KACA,GACF3H,OAAA,GACCnC,MAAM,GACX6J,UAAA9I,KAAA6I,iBAEArJ,EAAAkJ,OAKMlJ,CAhGmB,C,CAkHzByG,eAAA+C,GAEA,IAAAhJ,KAAAwG,YAAA,CAKEwC,EAAOhJ,KAAA4H,UAAAoB,IAAoB,EAA0BhJ,KAAK8E,QAAAJ,WAAA1E,KAAA8E,QAAAH,c,IAC1DwD,EAAOnI,KAAAiJ,eAAqCzJ,EAAAQ,KAASyI,UAAKN,GAAA,IAAAnI,KAAAyH,aAAAU,GAAAa,IAAAb,EAAA,CAEtD,IAACe,EAAQ,SAAiBf,EAAYgB,cAAYC,QAAA,gBAAA5E,EAClDI,EAAcyE,aAAarJ,KAAAiF,QAAAiE,GAE1B,WAAQf,EAAmBvD,EAAY0E,YAAWtJ,KAAIiF,QAAAjF,KAAA8E,QAAAyE,aAEvD3E,EAAa4E,SAAAxJ,KAAAiF,QAAAjF,KAAA8E,QAAAyE,aAAC,QAAQ5J,KAAAH,EAAAmJ,MAAA,CAAWnJ,EAAAmJ,MAAAhJ,GAACK,KAAAiF,QAAAzF,MAAAG,GAAAH,EAAAmJ,MAAAhJ,EAEtC,CAAoB,QAAA8J,KAAUjK,EAAAkJ,MAAA,CAAI,IAAKgB,EAAA,iBAAAlK,EAAAkJ,MAAAe,GAAA,QAAIzJ,KAAMgF,aAAAxF,MAAAiK,GAAAjK,EAAAkJ,MAAAe,GAAAC,CAAI,CAAY,IAAAC,EAAO,WAAAxB,EAAAgB,cAAAC,QAAA,gBAAA5E,EAAKI,EAAWyE,aAAArJ,KAAAiF,QAAA0E,EAAE,MAAA3J,KAAAmG,eAAAnG,KAAAgF,aAAAxF,MAAAyB,KAAAzB,EAAAkJ,MAAAzH,MAC1FjB,KAAAyH,YAAmBU,CAhBrB,C,oBAwBMlL,OAAK2M,YAAQ5J,KAAY8E,QAAI+E,UAC/B7J,KAAAwG,aAAmB,EACnBxG,KAAAyH,YAAmB,SACpBzH,KAAAiF,QAAA6E,gBAAA,SACHlF,EAAA0E,YAAAtJ,KAAAiF,QAAAjF,KAAA8E,QAAAyE,aAEAvJ,KAAAgF,aAAA8E,gBAAA,UAQM9J,KAAAwG,aACA,C,cAMHzC,EAAiB,IAChB/D,KAAI+J,W,eACF,E,KAEFzM,uBAAC,KACH,GAIF,WAJE0M,EAYGhK,KAAAoH,4BACWpH,KAAIiK,mBAAgCjK,KAAAiG,sBAK1CjG,KAAa+F,mBACvB/F,KAAAgG,iBAEAhG,KAAAiG,gBAAA,GASSjG,KAAQ+J,UAAO,CAAS,GAGjC,E,CAAAhG,EAAAmG,MAEA,C,sBAOE,IAAEC,EAAAnK,KAAAmK,Q,EACIrB,UAAYlE,EAAQwF,mB,EACpBC,YAAazF,EAAQwF,kBAAU,E,eAsB/BE,EAAQ,EAAAC,EAAA,EAASC,EACnB,G,YAEAL,QAAQE,YAAmB,eAAAC,EAAA,KAAAC,EAAA,KAAAC,EAAA,MAC9BxK,KAAAmK,QAAAvB,WAAA,aAAA0B,EAAA,KAAAC,EAAA,GAGH,C,UAaAtN,OAAAwN,oBAAA,SAAAzK,KAAA,CAEA0K,SAAA,I,OAUID,oBAAkB,SAAUzK,KAAA,CAChC0K,SAAA,IApmBE1K,KAAKiF,QAAO0F,UAAGtK,OAAcL,KAAM8E,QAACyE,aAEpCvJ,KAAAiF,QAAAzF,MAAAoL,UAAA,GACA5K,KAAKiF,QAAOwF,oBAAiB,SAAOjG,EAAqBxE,MACzD,IAAI6K,EAAA,CAGAnC,MAAC,GACDC,MAAC,IAGLkC,EAAKnC,MAAc,CACf1H,SAAU,GACVE,IAAC,GACHD,KAAA,GACAG,OAAA,GACFnC,MAAA,GAEI6J,UAAC,IAEL+B,EAAKlC,MAAc,CACfxJ,OAAC,GAEL6B,SAAA,I,IAEE,IAAArB,KAAAkL,EAAYlC,MAAA3I,KAAAiF,QAAAzF,MAAAG,GAAAkL,EAAAlC,MAAAhJ,G,IACZ,IAAA8J,KAAYoB,EAAAnC,MAAA1I,KAAAgF,aAAAxF,MAAAiK,GAAAoB,EAAAnC,MAAAe,GACZzJ,KAAA8E,QAAApE,cAAgB,oBAAAd,eAChBA,aAAA0D,OAAetD,KAAAgF,aAAAhF,KAAAsG,aACf1G,aAAA0D,OAAmBtD,KAAA2F,UAAA3F,KAAAsG,a,yBAUrB+D,GACA,IAAAS,GAAA,EAAAC,EAAAV,EAAA,0BAAAW,EAAAD,EAAAE,OAAA,GAAAC,cAAAH,EAAArF,MAAA,GAI4ClG,EAA5CmB,SAAAC,cAAA,WAA4CpB,MAgkBzC,OA/jBHuL,EAAK,IALL,CAAC,SAAe,MACd,IACF,MAGeI,KAAAH,EAAA,KAAAA,GAAAI,MAAA,KAAA1L,SAAA,SAAAqL,EAAApM,GACjB,QAAA0M,IAAA7L,EAAAuL,GAyjBK,OAFPD,EAAAC,GAEO,CAGT,IAESD,CACT,C,4gDA9qBoB,G;;;;;;ACNtB,SAASQ,EAAQC,GAaf,OATED,EADoB,mBAAXE,QAAoD,iBAApBA,OAAOC,SACtC,SAAUF,GAClB,cAAcA,CAChB,EAEU,SAAUA,GAClB,OAAOA,GAAyB,mBAAXC,QAAyBD,EAAIG,cAAgBF,QAAUD,IAAQC,OAAOnN,UAAY,gBAAkBkN,CAC3H,EAGKD,EAAQC,EACjB,CAEA,SAASI,EAAgBC,EAAUC,GACjC,KAAMD,aAAoBC,GACxB,MAAM,IAAIC,UAAU,oCAExB,CAEA,SAASC,EAAkBC,EAAQC,GACjC,IAAK,IAAItN,EAAI,EAAGA,EAAIsN,EAAMpN,OAAQF,IAAK,CACrC,IAAIuN,EAAaD,EAAMtN,GACvBuN,EAAWC,WAAaD,EAAWC,aAAc,EACjDD,EAAWE,cAAe,EACtB,UAAWF,IAAYA,EAAWG,UAAW,GACjDjO,OAAOkO,eAAeN,EAAQE,EAAWvM,IAAKuM,EAChD,CACF,CAEA,SAASK,EAAaV,EAAaW,EAAYC,GAG7C,OAFID,GAAYT,EAAkBF,EAAYxN,UAAWmO,GACrDC,GAAaV,EAAkBF,EAAaY,GACzCZ,CACT,CAiBA,SAASa,EAAgBC,GAIvB,OAHAD,EAAkBtO,OAAOwO,eAAiBxO,OAAOyO,eAAiB,SAAyBF,GACzF,OAAOA,EAAEG,WAAa1O,OAAOyO,eAAeF,EAC9C,EACOD,EAAgBC,EACzB,CAEA,SAASI,EAAgBJ,EAAGK,GAM1B,OALAD,EAAkB3O,OAAOwO,gBAAkB,SAAyBD,EAAGK,GAErE,OADAL,EAAEG,UAAYE,EACPL,CACT,EAEOI,EAAgBJ,EAAGK,EAC5B,CAuBA,SAASC,EAA2B7P,EAAMmB,GACxC,GAAIA,IAAyB,iBAATA,GAAqC,mBAATA,GAC9C,OAAOA,EACF,QAAa,IAATA,EACT,MAAM,IAAIuN,UAAU,4DAGtB,OAfF,SAAgC1O,GAC9B,QAAa,IAATA,EACF,MAAM,IAAI8P,eAAe,6DAG3B,OAAO9P,CACT,CASS+P,CAAuB/P,EAChC,CAEA,SAASgQ,EAAaC,GACpB,IAAIC,EAhCN,WACE,GAAuB,oBAAZC,UAA4BA,QAAQC,UAAW,OAAO,EACjE,GAAID,QAAQC,UAAUC,KAAM,OAAO,EACnC,GAAqB,mBAAVC,MAAsB,OAAO,EAExC,IAEE,OADAC,QAAQtP,UAAUuP,QAAQrP,KAAKgP,QAAQC,UAAUG,QAAS,IAAI,WAAa,MACpE,CAGT,CAFE,MAAOE,GACP,OAAO,CACT,CACF,CAqBkCC,GAEhC,OAAO,WACL,IACIhD,EADAiD,EAAQrB,EAAgBW,GAG5B,GAAIC,EAA2B,CAC7B,IAAIU,EAAYtB,EAAgB1M,MAAM0L,YAEtCZ,EAASyC,QAAQC,UAAUO,EAAOE,UAAWD,EAC/C,MACElD,EAASiD,EAAMG,MAAMlO,KAAMiO,WAG7B,OAAOhB,EAA2BjN,KAAM8K,EAC1C,CACF,CAEA,SAASqD,EAAeC,EAAQrD,GAC9B,MAAQ3M,OAAOC,UAAUuF,eAAerF,KAAK6P,EAAQrD,IAEpC,QADfqD,EAAS1B,EAAgB0B,MAI3B,OAAOA,CACT,CAEA,SAASC,IAkBP,OAhBEA,EADqB,oBAAZd,SAA2BA,QAAQe,IACrCf,QAAQe,IAER,SAActC,EAAQjB,EAAUwD,GACrC,IAAIC,EAAOL,EAAenC,EAAQjB,GAElC,GAAKyD,EAAL,CACA,IAAIC,EAAOrQ,OAAOsQ,yBAAyBF,EAAMzD,GAEjD,OAAI0D,EAAKH,IACAG,EAAKH,IAAI/P,KAAK0P,UAAUpP,OAAS,EAAImN,EAASuC,GAGhDE,EAAKE,KAPD,CAQb,EAGKN,EAAKH,MAAMlO,KAAMiO,UAC1B,C,uBAEA,IAAIW,EAAW,CAUb1E,KAAM,SAON2E,QAAS,EAOTC,QAAS,EAWTC,QAAS,EAOTC,IAAK,GAOLC,UAAU,EAOVC,YAAY,EAOZC,UAAU,EAUVC,OAAO,EAOPC,eAAgB,GAOhBC,cAAe,IAWfC,SAAU,GAOVC,WAAY,GAOZC,WAAY,GAOZC,kBAAmB,IAOnBC,QAAQ,EAORC,eAAgB,IAOhBC,oBAAqB,oCAOrBC,mBAAmB,EAOnBC,SAAU,GAWV/H,UAAW,MAcXgI,KAAM,EAONC,aAAc,EAWdC,YAAa,CAAC,EAQdC,QAAS,CACPC,UAAW,mBACXC,SAAU,kBACVrI,UAAW,CACTsI,IAAK,aACLC,IAAK,cAEPrG,KAAM,CACJsG,OAAQ,gBACRC,SAAU,mBAEZC,MAAO,CACLC,MAAO,sBACPC,OAAQ,wBAEVC,MAAO,CACLC,SAAU,0BAEZC,IAAK,CACHH,OAAQ,2BAWd,SAASI,EAAKC,GACZC,QAAQC,MAAM,iBAAiBC,OAAOH,GACxC,CASA,SAASI,EAAM1C,GACb,OAAO7I,SAAS6I,EAClB,CAmBA,SAAS2C,EAAS3C,GAChB,MAAwB,iBAAVA,CAChB,CAUA,SAAS4C,EAAS5C,GAChB,IAAIzE,EAAOoB,EAAQqD,GAEnB,MAAgB,aAATzE,GAAgC,WAATA,KAAuByE,CACvD,CAQA,SAAS6C,EAAW7C,GAClB,MAAwB,mBAAVA,CAChB,CAQA,SAAS8C,EAAY9C,GACnB,YAAwB,IAAVA,CAChB,CAQA,SAAS+C,EAAQ/C,GACf,OAAOA,EAAMjD,cAAgBjG,KAC/B,CAYA,SAASkM,EAAMC,EAAOC,EAAYC,GAChC,IAAIC,EAAa,CAAC,EAElB,IAAK,IAAI9O,KAAQ4O,EACXL,EAAWK,EAAW5O,IACxB8O,EAAW9O,GAAQ4O,EAAW5O,GAAM2O,EAAOG,EAAYD,GAEvDd,EAAK,gCAIT,IAAK,IAAIgB,KAASD,EACZP,EAAWO,EAAWC,GAAOC,QAC/BF,EAAWC,GAAOC,QAItB,OAAOF,CACT,CAUA,SAASG,EAAO3G,EAAK4G,EAAMC,GACzBhU,OAAOkO,eAAef,EAAK4G,EAAMC,EACnC,CAsBA,SAASC,EAAaC,EAAUC,GAC9B,IAAIzN,EAAU1G,OAAOoU,OAAO,CAAC,EAAGF,EAAUC,GAkC1C,OA5BIA,EAAS3O,eAAe,aAC1BkB,EAAQqL,QAAU/R,OAAOoU,OAAO,CAAC,EAAGF,EAASnC,QAASoC,EAASpC,SAE3DoC,EAASpC,QAAQvM,eAAe,eAClCkB,EAAQqL,QAAQnI,UAAY5J,OAAOoU,OAAO,CAAC,EAAGF,EAASnC,QAAQnI,UAAWuK,EAASpC,QAAQnI,YAGzFuK,EAASpC,QAAQvM,eAAe,UAClCkB,EAAQqL,QAAQjG,KAAO9L,OAAOoU,OAAO,CAAC,EAAGF,EAASnC,QAAQjG,KAAMqI,EAASpC,QAAQjG,OAG/EqI,EAASpC,QAAQvM,eAAe,WAClCkB,EAAQqL,QAAQO,MAAQtS,OAAOoU,OAAO,CAAC,EAAGF,EAASnC,QAAQO,MAAO6B,EAASpC,QAAQO,QAGjF6B,EAASpC,QAAQvM,eAAe,WAClCkB,EAAQqL,QAAQU,MAAQzS,OAAOoU,OAAO,CAAC,EAAGF,EAASnC,QAAQU,MAAO0B,EAASpC,QAAQU,QAGjF0B,EAASpC,QAAQvM,eAAe,SAClCkB,EAAQqL,QAAQY,IAAM3S,OAAOoU,OAAO,CAAC,EAAGF,EAASnC,QAAQY,IAAKwB,EAASpC,QAAQY,OAI/EwB,EAAS3O,eAAe,iBAC1BkB,EAAQoL,YAAc9R,OAAOoU,OAAO,CAAC,EAAGF,EAASpC,YAAaqC,EAASrC,cAGlEpL,CACT,CAEA,IAAI2N,EAAyB,WAM3B,SAASC,IACP,IAAIZ,EAAS7D,UAAUpP,OAAS,QAAsBwM,IAAjB4C,UAAU,GAAmBA,UAAU,GAAK,CAAC,EAElFtC,EAAgB3L,KAAM0S,GAEtB1S,KAAK8R,OAASA,EACd9R,KAAK2S,IAAMb,EAAOlO,cACpB,CAgEA,OAvDA2I,EAAamG,EAAW,CAAC,CACvB/S,IAAK,KACLgP,MAAO,SAAY5K,EAAO6O,GACxB,IAAIlB,EAAQ3N,GAAZ,CASK/D,KAAK2S,IAAIpU,KAAKyB,KAAK8R,OAAQ/N,KAC9B/D,KAAK8R,OAAO/N,GAAS,IAIvB,IAAI8O,EAAQ7S,KAAK8R,OAAO/N,GAAO5D,KAAKyS,GAAW,EAE/C,MAAO,CACLvS,OAAQ,kBACCL,KAAK8R,OAAO/N,GAAO8O,EAC5B,EAbF,CALE,IAAK,IAAIlU,EAAI,EAAGA,EAAIoF,EAAMlF,OAAQF,IAChCqB,KAAK8S,GAAG/O,EAAMpF,GAAIiU,EAmBxB,GAQC,CACDjT,IAAK,OACLgP,MAAO,SAAc5K,EAAOgP,GAC1B,GAAIrB,EAAQ3N,GACV,IAAK,IAAIpF,EAAI,EAAGA,EAAIoF,EAAMlF,OAAQF,IAChCqB,KAAKgT,KAAKjP,EAAMpF,GAAIoU,QAOnB/S,KAAK2S,IAAIpU,KAAKyB,KAAK8R,OAAQ/N,IAKhC/D,KAAK8R,OAAO/N,GAAOrE,SAAQ,SAAUkG,GACnCA,EAAKmN,GAAW,CAAC,EACnB,GACF,KAGKL,CACT,CA9E6B,GAgFzBO,EAAuB,W,SAchBC,EAAGC,GACV,IAAIrO,EAASmJ,UAAQpP,OAAA,QAAAwM,IAAA4C,UAAA,GAAAA,UAAA,MACrBtC,EAAgB3L,KAAAkT,GAChBlT,KAAKoT,GAAA,GACLpT,KAAKqT,GAAK,GACZrT,KAAAsT,GAAA,IAAAb,EACAzS,KAAA8Q,UAAA,EAQqB9Q,KAAAmT,W,KACnBZ,SAAKF,EAAAzD,EAAA9J,G,KACL+N,MAAO7S,KAAAuS,SAAS1D,O,UAchBqE,EAAA,CAQF,CAAGvT,IAAA,QACDgP,MAAK,WACL,IAAOkD,EAAS5D,UAASpP,OAAA,QAAAwM,IAAA4C,UAAA,GAAAA,UAAA,MAUzB,OATEjO,KAAIsT,GAAAN,KAAA,gBAEAzB,EAAQM,GAAA7R,KACNoT,GAAGzB,EAAG3R,KAAA6R,EAAA7R,KAAAsT,IAEVtC,EAAK,6CAGPhR,KAAAsT,GAAON,KAAI,eACbhT,IAQF,G,CAEEL,IAAA,S,MACE,WACA,IAAI4T,EAAYtF,UAAApP,OAAA,QAAkBwM,IAAlB4C,UAAa,GAAeA,UAAA,MAQ5C,OANIyD,EAAwB6B,GACrBvT,KAAQqT,GAAAE,EAGVvC,EAAQ,6CAENhR,IACT,GAeC,CACDL,IAAK,SACLgP,MAAO,WACL,IAAI4D,EAAQtE,UAAKpP,OAAA,QAAAwM,IAAA4C,UAAA,GAAAA,UAAA,MAWlB,OATCjO,KAAAuS,SAAWF,EAAArS,KAAAuS,YACbA,EAAA3O,eAAA,aAAA5D,KAAA6S,MAAAN,EAAA1D,SAQF7O,KAAAsT,GAAAN,KAAA,UAAGhT,IACD,G,KAIE,K,MAEA,SAAWwT,GAQf,OAPExT,KAAAoT,GAAAK,IAAAC,KAAAF,GAOFxT,IAAG,G,KAGC,O,MAEA,SAAW2T,GASZ,OARD3T,KAAAoT,GAAAQ,WAAAC,UAQF7T,KAAAoT,GAAAU,KAAAJ,KAAAC,GAAG3T,IACD,G,KAIE,U,MAIA,WAGF,OADEA,KAAAsT,GAAON,KAAI,WACbhT,IAOF,G,CAEEL,IAAA,O,MACE,WAEA,IAAAoU,EAAW9F,UAAApP,OAAA,QAAAwM,IAAA4C,UAAA,IAAAA,UAAA,GAQZ,OAPD8F,IAAA/T,KAAAuS,SAAAtD,SAAA8E,GAOF/T,KAAAsT,GAAAN,KAAA,QAAGhT,IACD,G,KAGE,QACF2O,MAAA,WAOC,OAAH3O,KAAAsT,GAAAN,KAAA,SAAGhT,IACD,G,KAGE,UACF2O,MAAA,WASC,OAAH3O,KAAA8Q,UAAA,EAAG9Q,IACD,G,KAIE,SACF2O,MAAA,WAQC,OAAH3O,KAAA8Q,UAAA,EAAG9Q,IACD,G,CAGAL,IAAA,KAOFgP,MAAA,SAAA5K,EAAA6O,GACE,OADC5S,KAAAsT,GAAAR,GAAA/O,EAAA6O,GACI5S,IACL,G,CAUAL,IAAK,S,MACH,SAAIsD,G,OAGFjD,KAAAuS,SAAArI,OAAAjH,CAEJ,GAOC,CACDtD,IAAK,WACL2O,IAAK,WACH,OAAOtO,KAAKgU,EACd,EAOAC,IAAK,SAAatH,GACZ4E,EAAM5E,GAAM3M,KAAAgU,GAAArH,EAClBqE,EAAA,wCAOF,G,CAEErR,IAAK,Q,IACH,WACF,OAAAK,KAAAkU,EAOF,EAAGD,IAAA,SAAAtV,GACDqB,KAAKkU,GAAA7C,EAAA1S,EACL,G,CASAgB,IAAK,O,IACH,WACF,OAAAK,KAAAuS,SAAArI,IACF,GAEA,CACFvK,IAAA,WAES2O,IAAA,WACG,OAAAtO,KAAAmU,EACR,E,gCAOAjB,C,CAtTuB,G,wCA+pBzB,SAAIkB,EAAiCC,EAAAC,EAAAxP,G,IACnCyP,EAASxB,EAAAyB,EAAA1J,EACT2J,EAAK,EACL3P,IAAIA,EAAY,I,IAChB4P,EAAA,WACAD,GAAO,IAAA3P,EAAA6P,QAAA,EAAAC,IAEPL,EAAI,K,EACEF,EAAAnG,MAAS6E,EAAAyB,G,IACXzB,EAAayB,EAAA,K,IAEd,W,IAEDK,EAAAD,IACAH,IAA6B,IAApB3P,EAAW6P,UAASF,EAAAI,G,IAC7BC,EAAKR,GAASO,EAAUJ,GAkB5B,OAjBE1B,EAAO/S,KAIPwU,EAAOvG,UACT6G,GAAA,GAAAA,EAAAR,GAEUC,IACRxW,aAAawW,GACbA,EAAW,MAEbE,EAAAI,EAEO/J,EAAAuJ,EAAAnG,MAAA6E,EAAAyB,GACTD,IAAAxB,EAAAyB,EAAA,OAEID,IAAc,IAAdzP,EAAAiQ,WAAcR,EAAA7W,WAAAgX,EAAAI,IACXhK,C,WAAekK,OAAA,WAAcjX,aAAAwW,GAClCE,EAAK,EAACF,EAAAxB,EAAAyB,EAAA,I,EAA4BS,CACpC,CACA,IAAAC,EAAe,CACb5E,IAAI,CACF,a,mFA0HJ,I,mCAAS6E,MAAAC,YAAY,IAAZD,EAAME,UAAMF,IAAAG,GAAAC,EAAApV,KAAAgV,GACf,OAAAI,CAIJ,CACF,QACA,CAQE,SAAOC,EAA2BF,GACpC,SAAAA,gBAAArY,OAAAwY,YAGA,C,SAOIC,EAAwBC,G,aACjBtX,UAAOqH,MAAMnH,KAAQoX,E,OAER,0B,wGAqkBtB3V,KAAA4V,W,UAW0BC,EAAe,C,CAEvClW,IAAA,KAUFgP,MAAA,SAAAmD,EAAA9O,EAAA8S,GAAG,IAAAzP,EAAA4H,UAAApP,OAAA,QAAAwM,IAAA4C,UAAA,IAAAA,UAAA,GACIqD,EAAAQ,OAAA,CACEA,IAGL,IAAI,IAAAnT,EAAA,EAAAA,EAAAmT,EAAAjT,OAAAF,IACQqB,KAAA4V,UAAA9D,EAAAnT,IAAAmX,EAAO9S,EAAAI,iBAAA0O,EAAAnT,GAAAqB,KAAA4V,UAAA9D,EAAAnT,IAAA0H,EAMrB,GAOC,CACD1G,IAAK,MACLgP,MAAO,SAASmD,EAAU9O,GACxB,IAAAqD,EAAY4H,UAASpP,OAAA,QAAAwM,IAAA4C,UAAA,IAAAA,UAAA,GACvBqD,EAAAQ,OAAA,CACFA,IAEO,QAAAnT,EAAA,EAAAA,EAAAmT,EAAAjT,OAAAF,IAAAqE,EAAAyH,oBAAAqH,EAAAnT,GAAAqB,KAAA4V,UAAA9D,EAAAnT,IAAA0H,EACT,GAGE,C,oDAKI,K,SAiDJ0P,EAAgB,C,oBAMd,I,YAEA,K,SAwHAC,EAAA9C,EAAA+C,GACF,O,mDAUOrN,CACP,E,UAUEsN,EAAAhD,EAAA+C,GACF,O,0DAUF,OAASrN,EAAAqN,EAAME,KAAOxH,MAAAyH,CACpB,E,CAUA,SAAAC,EAAAnD,EAAA+C,GACF,O,mBAUA,OAASrN,EAAAqN,EAAAK,OAAcC,KAAE,CACvB,E,YAWUrD,EAAA+C,G,OAYZO,OAAA,SAAA5N,G,wEAOA,OAASA,CACP,E,UAUI6N,EAA6BvD,EAAO+C,G,OAY1CO,OAAA,SAAA5N,G,4GAQSA,EAAA8N,EAAS3H,EAAOC,EAAUD,CACjC,E,CA0QE,IAAA4H,GAAoB,EAExB,IAAoB,IAAAC,EAAAxY,OAAAkO,eAAA,cAAcgC,IAAA,WAAYqI,GAAA,CAC1C,IAA4B1Z,OAAAmG,iBAAA,mBAAAwT,GAAY3Z,OAAAwN,oBAAA,mBAAAmM,EACxC,CAAJ,MAAI/I,GAAA,C,IAAcgJ,EAAAF,EAAYG,EAAA,CAAe,aAAW,aACpDC,EAAA,CAAgB,YAAa,aAAwBC,EAAA,CAAa,WACtE,cACE,U,iBAIC,YAED,YACA,UACA,c,MAsde,8BACfC,EAAS,GAAA7F,OAAA8F,EAAA,0BACTC,EAAe,GAAA/F,OAAA8F,EAAA,0BAwiBd,SACGE,EAAaC,GACjB,OAAA9F,EAAA8F,IAjqGgB9L,EAiqGhB8L,EAhqGOjZ,OAAOqB,KAAK8L,GAAK+L,OAAOC,QAAO,SAAUC,EAAGC,GAEjD,OADAD,EAAEC,GAAKlM,EAAIkM,GACJD,EAAEC,GAAID,CACf,GAAG,CAAC,K,8CAJN,IAAkBjM,C,KAyvGhBmM,GAAQ,CAERC,K,SA1xEEzE,EAAA+C,EAAA2B,G,IAEAD,EAAA,C,MAME,WACF3X,KAAA6X,KAAA3E,EAAAC,SACFnT,KAAA8X,MAAA9X,KAAA6X,KAAA3S,cAAA6S,GACA/X,KAAAgY,eACE,E,yBAKAhY,KAAKiY,OAASvC,EAAM1V,KAAAmF,QAAA+S,UAAAC,QAAA,SAAAzH,GAClB,OAAYA,EAAE/F,UAAApH,SAAA2P,EAAAX,SAAApC,QAAAO,MAAAC,MAChB,GAEA,G,kCAeA,OAAAgH,EAAAS,EACF,E,gBAOO9G,EAAekG,OAAA7W,SAAAuE,cAAAsS,IAClBhC,EAAcgC,GAAAG,EAAAS,GAAAZ,EAChBxG,EAAA,4CAEA,I,aAWA1C,IAAA,WACF,OAAAqJ,EAAAtE,EACA,EAMEY,IAAK,SAASoE,GACZ7C,EAA6B6C,GAAAV,EAAAtE,GAAAgF,EAC/BrH,EAAA,4CAAAI,OAAA2G,EAAA,eACF,I,eASFzJ,IAAA,WAES,OAAAqJ,EAAAG,MAAAI,SAAM,EACT,I,0BAMFP,EAAAK,e,IAEAL,C,EAisEFW,U,SA50CiCpF,EAAC+C,EAAe2B,G,MAE7C,C,gBAUF,IAAQ9O,E,SA/CqBoK,EAAA+C,EAAA2B,G,aAQ7BnB,G,OACEvD,EAAKG,GAAI,C,WAefkF,OAAS,SAAA3P,GACH,QAAYjK,EAAA,EAAAA,EAAA6Z,EAAA3Z,OAAAF,IAAA,CACd,IAAA8Z,EAAAD,EAAA7Z,G,qIAMA,E,CAeiB+Z,CAASxF,EAAA+C,GAAAsC,OAAA5J,GACxBgK,EAAgB,eAAcvH,QAAS,EAAGtI,EAAA,iBAC5CmN,EAAA0B,KAAAxS,QAAA3F,MAAAoZ,aAAAD,EAEA1C,EAAA0B,KAAAxS,QAAA3F,MAAAqZ,gBAAAF,E,gCAGA,E,OAOI,WAGF1C,EAAQ0B,KAAQxS,QAAM3F,MAAKsJ,UAAA,EAC7B,EAKAgQ,cAAA,WACE,IAAIja,EAAAoX,EAAiB8C,MAAAla,OAEjBgU,EAAAK,EAAcL,MAEhB/D,EAAOoE,EAAAX,SAAiBzD,QAG1B,OAAAmH,EAAOxC,IAAAuF,SAAA,MAAA/C,EAAAxC,IAAAuF,SAAA,MAAAna,GAAAgU,EAAA/D,IAEX+D,EAAA/D,GAAAjQ,CACA,E,6BAMA,IAAUoa,EAAkBhD,EAAS8C,MAAArC,WAAAxD,EAAAX,SAAAzD,QAC/B,OAACmH,EAAaxC,IAAAuF,SAAA,MAAgB/C,EAAexC,IAAAuF,SAC/C,OAG0B,EAAjBC,EACFA,C,wGAWXhD,EAAUrC,WAAWsF,OAAA,WACnBtB,EAAU5E,KAAM,kBAClBsF,EAAArE,IAAAgC,EAAA8C,MAAArC,WAAAxD,EAAAL,MACA,IACF,IAAAsG,EAAAlD,EAAA8C,MAAArC,WAAAT,EAAAqC,UAAAQ,gBAEA,OAASR,EAAArE,IAAAkF,EAAYlD,EAAOqC,UAAYc,oBACtC,I,2BAMAd,EAAIjY,QACJ,IACEiY,C,EAyvCF1E,W,uBA5uCW,EACTA,EAAA,CAQAyF,QAAK,SAAetO,GAClB,IAAIwH,EAAWW,EAAAX,SACf,OAAAzB,EACF,GAAAM,OAAArG,EAAA,SAAAqG,OAAAmB,EAAA1C,qBADkB,GAAQuB,OAAMrG,EAAU,KAAOqG,OAACpR,KAAQsZ,SAAA,OAAAlI,OAAAmB,EAAA1C,oBAG1D,EAOAoE,IAAA,WAEA,IAAAlJ,EAAAkD,UAAApP,OAAA,QAAAwM,IAAA4C,UAAA,GAAAA,UAAA,e,wDAQI,WACFgI,EAAQ0B,KAAQxS,QAAA3F,MAAAkC,WAAA,EAClB,E,MAQE,SAAgBxD,GAChBR,YAAQ,WACVQ,GAEA,GAAA8B,KAAAsZ,S,SAOM,WACNxI,GAAA,EACF9Q,KAAAiU,KACA,E,mBAOEnD,GAAc,EACZ9Q,KAAIiU,K,YAONL,EAAA,YAQAtF,IAAA,WACF,IAAAiE,EAAAW,EAAAX,SACA,OAAAW,EAAAqG,OAAA,WAAAtD,EAAAxC,IAAA+F,OAAAjH,EAAA3C,e,yBAO2BkD,GAAA,mBAAUc,EAAAK,K,IAQrC2D,EAAO9E,GAAG,CACR,eACF,SACA,mB,sBAGC,IAMH8E,EAAA9E,GAAA,kBAEAc,EAAA6F,Q,IAMA7B,EAAI9E,GAAA,sBAEAc,EAAAvT,QACF,IACEuT,C,EAsnCF8F,U,6BA3lDI,WAIA1Z,KAAA2O,MAAOuE,EAAAX,SAAAvK,SACT,EAQA2R,QAAI,SAAqBnG,GACvB,IAAAoG,EAAYpG,EAAK9N,MAAK,KACxB,OAAA1F,KAAA6Z,GAAA,OAAArG,EAAApI,MAAAwO,GAAAzO,KAAA2O,EAAAF,IAEApG,C,EASAqG,GAAA,SAAA7R,G,uBAQFwB,SAAA,WACAyM,EAAA0B,KAAAE,KAAOlN,UAAA1K,IAAWiT,EAASX,SAAApC,QAAAnI,UAAAhI,KAAA2O,OACzB,E,YAMS,WACTsH,EAAA0B,KAAAE,KAAAlN,UAAAtK,OAAA6S,EAAAX,SAAApC,QAAAnI,UAAAhI,KAAA2O,OAEA,G,mCAYA,OAAA+K,EAAAK,EACF,EAOW9F,IAAA,SAAAtF,GAAWoH,EAAAiE,QAAArL,IAAA,EAAA+K,EAAAK,GAAApL,EAAWqC,EAAY,yCAC3C,I,EAQA8B,GAAA,CACF,UACA,W,8BAMoC8E,EAAE9E,GAAA,UAAY,WAChD4G,EAAUzH,OACZ,I,2CAWFyH,EAASlQ,UACP,IACEkQ,C,EA2/CFO,K,SAlsEO/G,EAAM+C,EAAS2B,G,IACpBqC,EAAA,C,MAME,WACFja,KAAA2O,MAAAuE,EAAAX,SAAAvC,IAEA,G,0CASIiK,EAAMF,E,6CAcLpL,EAASuK,MAAM7H,EAAA1C,EAAAuK,QACdvK,EAAQ0C,EAAU1C,GACtBsL,EAAIF,GAAApL,C,MAONsL,EAAA,YAOF3L,IAAO,WAAI,IAAAK,EAAAsL,EAAAtL,MAAUG,EAAAoE,EAAAX,SAAAzD,QAAW,OAAAyC,EAAY5C,KAAAuL,OAAApL,EAAAH,EAAAuK,MAAApK,EAChC,EAAAH,EAAAG,CACZ,I,EAMEgE,GAAA,C,+BAKAmH,EAAAhI,O,IAEAgI,C,EAmoEFlB,M,SApiEE7F,EAAA+C,EAAA2B,G,IAEAmB,EAAA,C,YAME,W,IACF,IAAA9Z,EAAA,GAAAmS,OAAApR,KAAA0W,WAAA,MAEAuB,EAAAhC,EAAA0B,KAAAM,O,oDAYE,WACFhC,EAAA0B,KAAAxS,QAAA3F,MAAAP,MAAA,GAAAmS,OAAApR,KAAAma,YAAA,KACF,E,kBAQI,IADF,IAAKlC,EAAShC,EAAM0B,KAAAM,OACXtZ,EAAA,EAAAA,EAAWsZ,EAAKpZ,OAAOF,IAAMsZ,EAAAtZ,GAAAa,MAAAP,MAAA,GACtCgX,EAAA0B,KAAAxS,QAAA3F,MAAAP,MAAA,EACF,G,SAEE8Z,EAAA,U,IAME,WACF,OAAA9C,EAAA0B,KAAAM,OAAApZ,MACF,I,EAEEka,EAAA,S,IAME,WACF,OAAA9C,EAAA0B,KAAAG,MAAA5Y,WACF,I,EAEE6Z,EAAA,e,IAME,WACF,OAAAA,EAAArC,WAAAqC,EAAAla,OAAAoX,EAAAE,KAAAI,KAAAN,EAAAK,OAAAC,IACF,I,kBAQWjI,IAAA,WAAgB,OAAAyK,EAAA9Z,MAAAiU,EAAAX,SAAAzD,QAAAmH,EAAAgE,KAAAG,SAAAnE,EAAAE,KAAAiE,QAAU,I,MASrC,eACE,SACF,WACA,WACFrB,EAAAsB,cAEAtB,EAASuB,cACP,I,4CA48DAnE,K,SA/6EyBjD,EAAQ+C,EAAA2B,G,OAiB/B1J,MAAA,SAAA+J,G,mHAMgC,GACrBtZ,IAAIsZ,EAASpZ,OAAO,EAAAW,EAAQ0V,EAAclN,GAAA,OAAAoJ,OAAApR,KAAA2O,MAAA,QAC7CnP,EAAA0V,EAAuBlN,GAAA,M,uEAY1BxI,EAAS+a,WAAM,GAClB/a,EAAOgb,YAAA,EACT,CACF,G,SAEErE,EAAA,SAMA7H,IAAK,WACH,OAAO+C,EAAwB6B,EAAMX,SAAMvD,IAC7C,IAEFkD,EAAOiE,EAAM,QAOX7H,IAAK,WACH,OAAI6H,EAAAxH,MAAgBsH,EAAS8C,MAAOla,M,IAGxCqT,EAAAiE,EAAA,YAOW7H,IAAA,WAAe,IAAAQ,EAAAoE,EAAAX,SAAAzD,QAAW,OAAAqH,EAAAxH,OAAAG,EAAS,GAAAA,CAC5C,I,EAQKgE,GAAA,CACP,cACA,UACFsB,GAAA,WAEA+B,EAAAjI,MAAA+H,EAAA0B,KAAAxS,QAAA+S,S,QAMAN,EAAS9E,GAAA,sBACHqD,EAAA9V,OAAQ4V,EAAe0B,KAAExS,QAAA+S,S,IAE3B/B,C,EAm1EFrC,K,6BA1nEI,WACA9T,KAAKgU,GAAA,C,kBAQL,IAAAyG,EAAAza,KACFwZ,EAAAvL,UAAApP,OAAA,QAAAwM,IAAA4C,UAAA,GAAAA,UAAA,KACFjO,KAAAwZ,SACA5B,EAAA5E,KAAA,QACE0H,SAAA1a,KAAA2O,Q,oDAKK+L,SAAeD,EAAA9L,OAEpB,GAEA,G,qBAQFL,IAAA,WACA,OAAAwF,EAAAE,EACE,E,IAME,SAAOrF,GACTmF,EAAAE,GAAAvC,EAAA9C,GAAA,EAAA0C,EAAA1C,EACF,I,EAEEmF,EAAA,a,IAME,WACA,OAAImC,EAAY8C,MAAKrC,WAASxD,EAAAL,K,MAOhCiB,EAAA,S,eAQF,IAAU0F,EAAAxZ,KAAAwZ,OAAC5Q,EAAA5I,KAAA4I,UAAgB,OAAAqN,EAAAyD,UAAAG,GAAA,OAAAjR,EAAA4Q,EAAoB5Q,EAAA4Q,CAC7C,I,EAOA1G,GAAA,C,kCAKAgB,EAAAJ,M,OA8iEF4C,O,6BAt2DI,WACAtW,KAAI6D,MAAA,GAKAqP,EAAAqG,OAAa,cAAQvZ,KAAA6D,MAAA7D,KAAA2a,U,2BAQnB1M,UAAIpP,OAAe,QAAiBwM,IAAd4C,UAAU,GAAIA,UAAA,M,EACpCgI,EAAM0B,KAAUM,O,EACN/E,EAACX,SAAAzD,EAAA8L,EAAA9L,QAAAqB,EAAAyK,EAAAzK,QAAAF,EAAA2K,EAAA3K,a,GACb,I,EAAApR,O,QAEAgc,KAAsB3H,EAAAX,SAAcvC,K,EAC9BlB,EAAS+L,EAAsB1d,KAAImC,MAAAwP,EAAA,G,EAEvCmJ,EAAOvS,MAAU,EAAIoV,GAAQC,U,EAEvB9C,EAAOvS,OAAC,EAAAoV,GAChBtD,EAAA,EAAAA,EAAAra,KAAA+K,IAAA+H,EAAA9S,KAAA6d,MAAAlM,EAAAmJ,EAAApZ,SAAA2Y,IAAA,CACF,QAAA7Y,EAAA,EAAAA,EAAAsc,EAAApc,OAAAF,IAAA,CACD,IAAAgS,EAAAsK,EAAAtc,GAAAuc,WAAA,GAEMvK,EAAAhG,UAAA1K,IAAAkQ,EAAAO,MAAAC,OACT9M,EAAA1D,KAAAwQ,EAEA,C,oFAKQ9M,EAASsX,QAASC,EACpB,CACA,CAIJ,OAAIvX,C,EAeNoX,OAAA,WAUE,IARF,IAAApX,EAAA7D,KAAA6D,M,kFAKQoX,EAASpX,EAAA6B,OAAS,EAAA2V,GAAAN,UACpB9b,EAAQ,GAAAmS,OAAU6E,EAAA8C,MAAArC,WAAA,MAEb/X,EAAI,EAAGA,EAAIsc,EAAMpc,OAAQF,IAChCwG,EAAAtD,YAAgBoZ,EAAQtc,IAE5B,QAAA2c,EAAA,EAAAA,EAAAC,EAAA1c,OAAAyc,IAAAnW,EAAAqW,aAAAD,EAAAD,GAAArD,EAAA,IACF,QAAAwD,EAAA,EAAAA,EAAA5X,EAAAhF,OAAA4c,IAAA5X,EAAA4X,GAAAjc,MAAAP,OACA,EAMEoB,OAAK,WAEL,IADE,IAAAwD,EAAQ7D,KAAA6D,MACVlF,EAAA,EAAAA,EAAAkF,EAAAhF,OAAAF,IAAAsX,EAAA0B,KAAAxS,QAAA3B,YAAAK,EAAAlF,GACF,GA2CA,O,YAlCE2P,IAAA,WACF,OAAA2H,EAAA8C,MAAArC,WAAAT,EAAAE,KAAAxH,OAAA2H,EAAAzS,MAAAhF,MACA,IASA+Y,EAAA9E,GAAA,qBACAwD,EAAAjW,S,oBAGC,IAMHuX,EAAA9E,GAAA,2BAEII,EAAAqG,OAAA,aAAAjD,EAAe2E,QACjB,I,EAMEnI,GAAA,sBAEAwD,EAAKjW,QACP,IACAiW,C,EA0uDAoF,O,SA/pDaxI,EAAA+C,EAAA2B,G,gCAYT5X,KAAG2b,MACL,E,KAQE,WACFC,EAAA9I,GAAA,SAAA7V,OAAAmX,GAAA,WACFwD,EAAA5E,KAAA,SACA,GAAAE,EAAAX,SAAAxC,U,EAQA8L,OAAA,WACOD,EAAAE,IAAA,SAAA7e,OACT,GAOA,OAJI2a,EAAA9E,GAAA,sBACF4I,EAAKG,SACLD,EAAKG,SACL,IACFL,CACA,EAsnDAM,M,SAt8DsB9I,EAAA+C,EAAA2B,G,MAChB,CAQF3F,MAAA,WACE2F,EAAA5E,KAAW,gBACbhT,KAAAic,YAEAjc,KAAAkc,c,iCASM,W,EACIvE,KAAAE,KAAUlN,UAAI1K,IAAQiT,EAAMX,SAAMpC,QAAAjG,KAAAgJ,EAAAX,SAAArI,M,EAO5CgS,YAAA,W,sDAKAxL,EAAA/F,UAAwB1K,IAAAkQ,EAAAO,MAAgBE,QAClCuL,EAA8BzL,GAAQhR,SAAQ,SACvC0c,GAEXA,EAAgBzR,UAAKtK,OAAU8P,EAAOO,MAAKE,OAC3C,I,uEAWJqF,EAAU0B,KAAAE,KAAAlN,UAAAtK,OAAA6J,EAAAgJ,EAAAX,SAAArI,OAAC+L,EAAA0B,KAAAM,OAAAvY,SAAA,SAAA0c,GAAWA,EAAAzR,UAAAtK,OAAAqQ,EAAAE,OAAW,GAC/B,G,OAQFgH,EAAO9E,GAAG,CAAC,UAAU,WAAW,WAC9BkJ,EAAMK,eACR,I,EAOEvJ,GAAM,CACR,SACA,WACF,WAEAkJ,EAAS/J,OACP,I,EAKIa,GAAI,cAAW,W,EAEfoJ,a,IAKFF,C,EAi3DAvI,I,6CAj0FIO,IAAK,C,gBASCsI,G,MAIAtc,K,yBAEK8P,mBAAmBoD,EAAMW,U,KACjCyI,O,EAEDtJ,KAAO,aAAKhT,KAAasc,M,KACzBC,YACF3E,EAAA5E,KAAA,MAAAhT,KAAAsc,MACDrG,EAAArC,WAAAsF,OAAA,WACHuB,EAAA+B,WAAA5E,EAAA5E,KAAA,YAAAyH,EAAA6B,MAEA7B,EAAAgC,SAAA7E,EAAA5E,KAAA,UAAAyH,EAAA6B,M,oDAMM1E,EAAW5E,KAAK,YACPyH,EAAK6B,MACdpJ,EAAQuG,QAGR,I,2BASF6C,EAACtc,KAAAsc,KAAAzd,EAAAmB,KAAAnB,OAED6d,EAAMJ,EAAKI,MAAG1U,EAAAsU,EAAAtU,UACd2U,EAAA,EAEF,SAAA3U,EAKE,OAAAkL,EAAAX,SAAAnD,OAAAiC,EAAAqL,GAAA7d,OACAqU,EAAAL,MAAAhU,QAKAqU,EAAML,MAAQ6J,GAOf,GAAC,MAAA1U,GAAwB,MAAA0U,E,GAWxB,MAAA1U,GAAA,MAAA0U,E,IAOa,MAAb1U,IACE2U,EAAczJ,EAAAX,SAAAzD,SAAA,GAIhB,MAAA9G,GAAA,MAAAA,GAAA,MAAA0U,EAAA,CACD,IAAA7J,E,0BAwFL,OAAAK,EAASqG,OAAA,YAA6B1G,EAAQ8J,EACxC9J,GAAS8J,EAAU9J,EAAA8J,E,CAzFpBC,CAAAD,GAKH,OAHE9J,EAAAhU,IAAAmB,KAAKgU,IAAA,QACPd,EAAAL,M,SA2GSA,EAAA8J,GAGT,IAAA9d,EAAY4U,EAAK5U,OACnB,GAAAgU,GAAAhU,EAAA,OAAAgU,EACA,GAAAK,EAAAqG,OAAA,mBAAA1G,GAAAhU,EAAA,G,sDAQS,EAGP,OAAI4U,EAAAoJ,UAAahe,EAEf1B,KAAA6d,MAAAnc,EAAA8d,I,CA7HFG,CAAAjK,EAAA8J,G,gGA8IOxf,KAAA4f,KAAAlK,EAAA8J,GACM,GAAIA,C,KAtIjB,OAFSK,EAAS,IAAAhd,KAAUgU,IAAA,QAC1Bd,EAAOL,M,SA2JFA,EAAA8J,GACT,IAAA9d,EAAA4U,EAAA5U,OAEA,GAAAgU,GAAA,SAAAA,EACE,GAAAK,EAAAqG,OAAA,mBAAA1G,GAAAhU,EAAA,G,qBAKA,OAAK4U,EAAAoJ,WAAepJ,EAAA+I,UAAA3d,EACX1B,KAAK6d,MAAEnc,EAAA8d,KAGhB,Q,CAxKoBM,CAAID,EAAAL,GAGxB,C,4EA1BIzJ,EAAAL,MAAA,OATEK,EAAAL,MAAchU,C,EA4CpB2d,QAAA,W,yBASE,WAIA,OAAKtJ,EAAOL,OACH7S,KAAKnB,M,EAgBhBma,SAAA,W,yFAMe,OAAbhR,EAAuD,MAAnChI,KAAasc,KAAMtU,WAAuC,MAAlBhI,KAAAsc,KAAYI,MAE5E,OAAA1U,EAAA,MAAAhI,KAAAsc,KAAAtU,WAAA,MAAAhI,KAAAsc,KAAAI,MACA1c,KAAAsc,KAAAtU,e,SAQE6U,QAAI,WAEA,OAAM3J,EAAOqG,OAAA,WACA,WAARrG,EAAAX,SAAQxD,SAAAmE,EAAAX,SAAAnD,KAGjB,G,yCAgHIpP,KAAOkd,E,qEAWNR,MAASS,EAAM9L,EAAA8L,GAAA9L,EAAA8L,KAAA,E,MAIlB1J,EAAA,UAUFnF,IAAA,W,wCAME,OAAAtO,KAAO6c,UAAOhe,EAAA,GAAAwS,EAAAkB,EAAAzD,SAAA,GAAAuC,EAAAkB,EAAAxD,SAChBlQ,EAAA,CACF,IAEFqT,EAAAuB,EAAA,UAOAnF,IAAS,WACA,OAAItO,KAAOgU,EACpB,I,GAigFEoJ,M,SAzmCclK,EAAA+C,EAAA2B,G,oBASZyF,EAAO,E,GACA,EACPhX,IAAAwQ,GAAA,CAEAzQ,SAAA,G,yBASIkX,gB,QAOD,SAAAvZ,GACH,IAAA+M,IAAAoC,EAAApC,SAAA,CAEA9Q,KAAA6T,U,0CAKMwJ,EAAchM,EAAOkM,EAAAC,OACrBxd,KAACyd,gBACHzd,KAAI0d,eAIJ9F,EAAI5E,KAAQ,c,iBAODjP,G,IAEXmP,EAAIpC,SAAW,C,IACb8J,EAAM1H,EAAeX,SAAA9C,EAAAmL,EAAAnL,WAAAD,EAAAoL,EAAApL,WAAAW,EAAAyK,EAAAzK,QACrBoN,EAAAvd,KAAW2d,QAAU5Z,GACrB6Z,EAAAvM,EAAmCkM,EAAQM,OAAQC,EACnDC,EAAO1M,EAAKkM,EAAAC,OAAAH,EACdW,EACE7gB,KAAO8gB,IAAKL,GAAA,GAEfM,EAAA/gB,KAAA8gB,IAAAF,GAAA,GACHI,EAAAhhB,KAAAihB,KAAAJ,EAAAE,GAEAG,EAAAlhB,KAAAihB,KAAAF,G,uCAQQ,S,kCAj1EHI,W,IA+0EArI,EAAkB0B,KAAEE,KAAAlN,UAAA1K,IAAAkQ,EAAAE,UAClBuH,EAAM5E,KAAQ,a,gBAgBfjP,G,IACAmP,EAAApC,SAAgB,CAGlB,IAAAyN,EAAqBrL,EAAAX,SAAiBhD,EAAQgP,EAAQhP,SAAAE,EAAA8O,EAAA9O,WAAAU,EAAAoO,EAAApO,QAClDoN,EAACvd,KAAA2d,QAAe5Z,GAChBya,EAACxe,KAAcwe,UAAAza,GACnB0a,EAAYlB,EAAAM,MAAAC,EACbY,EAAA,IAAAC,EAAAxhB,KAAAyhB,GACH5e,KAAAyZ,SAEAgF,EAAAD,GAAAE,EAAAjP,EAAAwG,EAAAxC,IAAAC,KAAAuC,EAAAyD,UAAAC,QAAA,GAAAvI,OAAA7B,EAAA,O,0EAKA0G,EAAgB0B,KAAAE,KAASlN,UAAAtK,OAAiB8P,EAAAE,UACpCrQ,KAAA6e,kBAEA7e,KAAA8e,iBAIAlH,EAAA5E,KAAA,Y,GAaNsK,eAAA,W,sGAKA7C,EAAAsE,MAAkBhb,EAChB,GAAAsC,GACAiJ,GAAWsM,EAAA9I,GAAAgE,EAA4B,GAAKb,EAAS0B,KAAAxS,SAAA,SAAApB,GACvD0W,EAAAsE,MAAAhb,EAEA,GAAAsC,E,mBAQY,W,EACRyV,IAAOhF,EAAK,GAAAb,EAAA0B,KAAAxS,QAAAkB,GACduV,EAAGE,IAAMhF,EAAoB,GAAAb,EAAA0B,KAAAxS,QAAAkB,EAC/B,EAOAoX,cAAA,WACE,IAAAuB,EAAWhf,KACb4b,EAAA9I,GAAAiE,EAAAd,EAAA0B,KAAAxS,QAAAiP,GAAA,SAAArQ,GAEAib,EAAA1C,KAAAvY,E,4CASW,WACT6X,EAAAE,IAAA/E,EAAAd,EAAA0B,KAAAxS,QAAAkB,EACF,EAOAqX,aAAA,WACE,IAAAuB,EAAWjf,KACb4b,EAAA9I,GAAAkE,EAAAf,EAAA0B,KAAAxS,SAAA,SAAApB,GAEAkb,EAAAC,IAAAnb,E,KAWA+a,eAAA,WAEAlD,EAAAE,IAAA9E,EAAAf,EAAA0B,KAAAxS,Q,UAQM,SAAApB,GAIJ,OAAAob,EAA8BnF,QAAAjW,EAAAmG,OAAA,EAAAnG,EAChCA,EAAA4Z,QAAA,IAAA5Z,EAAAqb,eAAA,EAEA,E,UAME,SAAgBrb,GAChB,IAAAwO,EAAWW,EAAUX,SACrB,OAAA4M,EAAWnF,QAAAjW,EAAAmG,OAAA,EAAAqI,EAAAjD,cACbiD,EAAAlD,cAEA,E,OAME,WAGF,OAFEyB,GAAW,EACXmF,EAAWrC,WAAA6F,SACbzZ,IACF,EAOE6T,QAAA,W,OACF/C,GAAA,EACAmF,EAAArC,WAAAC,U,gBASEf,GAAO,eAAO,WAChBmD,EAAA0B,KAAAE,KAAAlN,UAAA1K,IAAAiT,EAAAX,SAAApC,QAAAC,UACA,I,oEASAgN,EAAI0B,iBACAlD,EAAAG,S,OA42BJsD,O,+BAz1BEpN,MAAA,W,aASA0J,KAAA,W,iDAQFE,OAAA,WACAD,EAAAE,IAAA,YAAA7F,EAAA0B,KAAAxS,Q,EAQAma,UAAA,SAAAvb,GACOA,EAAAwb,gBACT,G,kCAQEF,EAAIxD,SACJD,EAAAG,S,yEA4CE/b,KAAAwf,GAAAvJ,EAAA0B,KAAAxS,QAAAK,iBAAA,K,aASAmW,KAAA,W,gDAQI,W,EACAG,IAAM,QAAA7F,EAAc0B,KAAAxS,Q,EASxBsa,MAAA,SAAiB1b,GACf2b,IAEI3b,EAAC4b,kBACH5b,EAAKwb,iB,oBAeT,G,MAAQK,EAAS,CACf,QAAYjhB,EAAA,EAAKA,EAAAqB,KAAA6D,MAAAhF,OAAAF,IAAAqB,KAAA6D,MAAAlF,GAAAkhB,WAAA,EAEbD,GAAU,C,QAKZ5f,I,EAOJ8f,OAAA,W,0EAKKF,GAAS,CACZ,CACF,OAAA5f,IACF,G,oBASAsO,IAAA,W,eASAsJ,EAAA9E,GAAA,yBACAiN,EAAAzc,Q,MAOEwP,GAAQ,aAAM,WACdmD,EAAOrC,WAAOsF,OAAA,WAChB6G,EAAAD,QACA,GACF,IAKIlI,EAAA9E,GAAA,sBACJiN,EAASD,SACPC,EAAAlE,S,oCAUE3I,EAAA+C,EAAA2B,GAKC,IACDgE,EAAO,IAAAoE,E,IACLnJ,GAAA,C,qEAXU,mC,KAqCVzD,GAAK6C,EAAW0B,KAAAE,KAAArS,iBAAA0R,GAQlBlX,KAAAigB,eAAoB,CACbxL,SAAQwB,EAAY0B,KAAGE,KAAQrS,iBACrByR,GAEjBiJ,KAAAjK,EAAA0B,KAAAE,KAAArS,iBAAA2R,I,oBAaAgJ,UAAA,W,kFAQM,WAEJ,IAAI,IAACxhB,EACH,EAAAA,EAAAqB,KAAAogB,GAAAvhB,OAAAF,IAAAqB,KAAAsJ,YAAAtJ,KAAAogB,GAAAzhB,GAAAuZ,S,EASJ1O,SAAA,SAAA6W,GAEA,IAAA9N,EAAAW,EAAAX,S,0DAMA4J,EAAkCvW,GAAUlG,SAAA,SAAA0c,GACtCA,EAAOzR,UAAetK,OAAMkS,EAAApC,QAAAY,IAAAH,OAE5B,IAKN,E,YAUO,SAAsByP,GAE3B,IAAIza,EAAMya,EAAUnN,EAClBL,OAGEjN,GAAMA,EAAK+E,UAAKtK,OAAW6S,EAAIX,SAC7BpC,QAACY,IAAAH,OAET,E,gDAOA,IAAAsP,EAAAI,EAAiBL,eAASC,KACpBzL,EAAW6L,EAAML,eAAQxL,SAE7BzU,KAAKugB,gBAAWL,EAAUzL,GAIZ,IAAdvB,EAAML,OAAkB7S,KAAIwgB,aAAE/L,GAC5BvB,EAAAL,QAAAoD,EAAAxC,IAAQ5U,QAAMmB,KAAQwgB,aAAUN,E,mHAWpCO,EAAA/gB,SAAc,SAASghB,GACjBhL,EAAyBgL,GAAAhhB,SAAA,SAAAX,GAEpBA,EAAQ4L,UAAUtK,OAAMkS,EAAUpC,QAAIU,MAAMC,SAIrD,G,kHAYF2P,EAAA/gB,SAAa,SAASghB,GACfhL,EAA6BgL,GAChChhB,SAAS,SAASX,GAEtBA,EAAA4L,UAAA1K,IAAAsS,EAAApC,QAAAU,MAAAC,SAEA,G,KAWA6P,YAAA,W,gFAQW,W,IACP,IAAAhiB,EAAO,EAAGA,EAAAqB,KAAAoT,GAAAvU,OAAcF,IAAWqB,KAAE6b,OAAU7b,KAAEoT,GAAAzU,GAAAuZ,S,mBAUrD,IAAQ,IAAAvZ,EAAA,EAASA,EAAAV,EAAeY,OAAEF,IAC3Bid,EAAI9I,GAAI,QAAO7U,EAASU,GAAQqB,KACnCyf,OAAY7D,EAAA9I,GAAA,aAAA7U,EAAAU,GAAAqB,KAAAyf,MAAApZ,E,+DAYT,cACLpI,EAAKU,G,oBAcFkY,GAAe,eAAA9S,EAAAmG,MAAAnG,EAAAwb,iBAClB,IAAAvX,EAAgBjE,EAAE6c,cAAAC,aAAA,kBACpB5K,EAAAxC,IAAAC,KAAAuC,EAAAyD,UAAAC,QAAA3R,GACF,G,oBAO0BsG,IAAA,WAAe,OAAYgS,EAAAlN,EACnD,I,EAMwBN,GAAA,CAAQ,cAChC,eACF,WACAwN,EAAAH,W,MAMErN,GAAA,CACA,cACA,QACF,WACAwN,EAAOQ,eACT,I,8CAQER,EAAIS,eACAnF,EAAAG,S,OAiZJiF,S,+BA5XE/O,MAAA,W,kCASA0J,KAAA,W,0CASM,WAIJC,EAAIE,IAAM,QAASnb,SAGrB,EAQFsgB,MAAS,SAACld,GAAC,IAAAwL,EAAA2D,EAAAX,SAAAhD,SAAW,eAAAxL,EAAAmd,MAAAjL,EAAAxC,IAAAC,KAAAuC,EAAAyD,UAAAC,QAAA,GAAAvI,OAAA7B,EAAA,OAAuB,cAAZxL,EAAYmd,MAAAjL,EAAAxC,IAAAC,KAAAuC,EAAAyD,UAAAC,QAAA,GAAAvI,OAAA7B,EAAA,MAC3C,G,SAQAuD,GAAA,CACF,UACA,W,qBAGC,IAMH8E,EAAA9E,GAAA,qBAEAkO,EAAS/O,OACP,IAKA2F,EAAI9E,GAAA,WAAa,WACb8I,EAAAG,S,OAgUJoF,S,oBAnTEvF,EAAA,IAAAoE,EAEAmB,EAAA,C,MAME,WACFnhB,KAAAyZ,SAEAzZ,KAAA+e,Q,oCASAtF,OAAA,W,oBASO,WAILzZ,KAAKsT,IAAA,C,mBAaH,IACDmH,EAAAza,KACHA,KAAAsT,KAEAtT,KAAAyZ,S,2EAKMxD,EAAgBxC,IAAAC,KAAA,KACb+G,EAAGsE,QACZnH,EAAA5E,KAAA,WAEA,GAAAhT,KAAAohB,O,kBAYEphB,KAAAkU,GAAAmN,cAAArhB,KAAAkU,G,sEAaM8K,EAAS1L,IAAA0L,EAASsC,MACxB,I,EAAYxO,GAAA,WAAAmD,EAAA0B,KAAAE,MAAA,WAAamH,EAAA1L,IAAA0L,EAAAD,O,GAC3B,E,qCASK,YACH9I,EAAI0B,KAAWE,K,GAwFnB,O,EAjFEsJ,EAAA,QAQF7S,IAAO,WAAI,IAAAW,EAAAgH,EAAA0B,KAAAM,OAAA/E,EAAAL,OAAAgO,aAAA,uBAAW,OAAAxP,EAAApC,GAAuBiE,EAAAX,SAAAtD,SAC3C,I,2BAWF,WAAWkS,EAAAtF,Q,IAGmBjE,EAAE9E,GAAA,CAC9B,aACA,cACF,WACA,W,0BAOA,Y,WAAwBqO,EAAAtN,UAAcsN,EAAAG,M,UAUtC,YAAW,cAAS,WAClBH,EAASpC,O,MASTjM,GAAA,CACF,SACA,W,oBAGC,IAMH8E,EAAA9E,GAAA,qBAEAqO,EAAAlP,O,IAOA2F,EAAS9E,GAAA,sBACH8I,EAAAG,S,IAMGoF,CACT,E,qBAe+BjO,EAAA+C,EAAA2B,G,8CA4BnBxZ,OAAIoU,OAAO,GAAAD,G,EAGZ,C,gDAYF,IAAO,IAAAgP,KAAUlK,EAAA,GAAYA,EAAMzT,eAAA2d,IAC1CtkB,OAAAukB,WAAA,eAAApQ,OAAAmQ,EAAA,QAAAE,QAAA,OAAApK,EAAAkK,GAKA,OAAUjP,CACR,GA8BF,OAvBAlU,OAAOoU,OAAGD,EAAUmP,EAAYC,MAAAtK,IAIhCuE,EAAA9I,GAAA,SAAA7V,OAAAmX,GAAA,W,mDAQAwD,EAAO9E,GAAA,qBACTuE,EAAAD,EAAAC,GAEI/E,EAAAlU,OAAAoU,OAAA,GAAAD,EACF,IAIAqF,EAAA9E,GAAW,sBACX8I,EAAME,IAAA,SAAA7e,OACN,IACMykB,C,MA6BoB,SAAAE,IA9uH5B,SAAmBC,EAAUC,GAC3B,GAA0B,mBAAfA,GAA4C,OAAfA,EACtC,MAAM,IAAIhW,UAAU,sDAGtB+V,EAASxjB,UAAYD,OAAO2jB,OAAOD,GAAcA,EAAWzjB,UAAW,CACrEqN,YAAa,CACXiD,MAAOkT,EACPxV,UAAU,EACVD,cAAc,KAGd0V,GAAY/U,EAAgB8U,EAAUC,EAC5C,C,CAkuHuB5O,EAAU0O,G,MAC3BxU,EAAY8F,G,SACdA,IACA,OAAFvH,EAAA3L,KAAAkT,GAAE8O,EAAA9T,MAAAlO,KAAAiO,UAEF,C,OACA1B,EAAA2G,EAAA,C,4KAP0B,C,GCnxH5B,IAAI+O,GAAUthB,SAASsD,KACvB,IAAIie,EAAA5d,GAAJ,CAAiB2d,IAAS,WACtB,GAAIA,GAAQE,aAAe,IAAK,CAEdxhB,SAAS6E,iBAAiB,YAChC9F,SAAQ,SAAS0iB,GACrB,IAAIC,EAAcD,EAAG,CACjB1d,WAAY,IACZC,cAAe,GACfW,kBAAmB,gBACnBP,qBAAsB,mBAE9B,GACJ,CACJ,IA4BA,MAAMud,GAAmB3hB,SAASsD,KAAK0G,UAAUpH,SAAS,QACpDgf,GAAqB5hB,SAASsD,KAAK0G,UAAUpH,SAAS,gBAEvD+e,IAAoBC,KACrB,IAAIC,GAAM,SAAU,CAChBtY,KAAM,SACN2E,QAAS,EACTI,SAAU,MACXgD,QAGN,WAIG,IAAIwQ,EAAUC,SAASC,SAASvX,MAAM,KAAK,GACvCwX,EAAYjiB,SAAS6E,iBAAiB,gBAE1C,GAAgB,KAAZid,EAIJ,GAAgB,gBAAZA,EAIJ,IAAK,IAAI9jB,EAAI,EAAGkkB,EAAID,EAAU/jB,OAAQF,EAAIkkB,EAAGlkB,KACkB,IAAvDikB,EAAUjkB,GAAGkiB,aAAa,QAAQ7G,QAAQyI,IAC1CG,EAAUjkB,GAAGgM,UAAU1K,IAAI,kBAL/B2iB,EAAU,GAAGjY,UAAU1K,IAAI,kBAJ3B2iB,EAAU,GAAGjY,UAAU1K,IAAI,YAYnC,CApBC,GAsBA,WAIG,IAAI6iB,EAAcniB,SAASuE,cAAc,gBACrC6L,EAAMpQ,SAASuE,cAAc,QAC7B6d,EAAUpiB,SAASuE,cAAc,qBAErC4d,EAAY1f,iBAAiB,SAAS,WAClC0f,EAAYnY,UAAUqY,OAAO,UAC7BjS,EAAIpG,UAAUqY,OAAO,aACrBD,EAAQpY,UAAUqY,OAAO,gBAC7B,GAEJ,CAdC,E","sources":["node_modules/css-element-queries/src/ResizeSensor.js","node_modules/sticky-sidebar/src/sticky-sidebar.js","node_modules/@glidejs/glide/dist/glide.esm.js","src/js/app.js"],"sourcesContent":["'use strict';\n\n/**\n * Copyright Marc J. Schmidt. See the LICENSE file at the top-level\n * directory of this distribution and at\n * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n */\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define(factory);\n    } else if (typeof exports === \"object\") {\n        module.exports = factory();\n    } else {\n        root.ResizeSensor = factory();\n    }\n}(typeof window !== 'undefined' ? window : this, function () {\n\n    // Make sure it does not throw in a SSR (Server Side Rendering) situation\n    if (typeof window === \"undefined\") {\n        return null;\n    }\n    // https://github.com/Semantic-Org/Semantic-UI/issues/3855\n    // https://github.com/marcj/css-element-queries/issues/257\n    var globalWindow = typeof window != 'undefined' && window.Math == Math\n        ? window\n        : typeof self != 'undefined' && self.Math == Math\n            ? self\n            : Function('return this')();\n    // Only used for the dirty checking, so the event callback count is limited to max 1 call per fps per sensor.\n    // In combination with the event based resize sensor this saves cpu time, because the sensor is too fast and\n    // would generate too many unnecessary events.\n    var requestAnimationFrame = globalWindow.requestAnimationFrame ||\n        globalWindow.mozRequestAnimationFrame ||\n        globalWindow.webkitRequestAnimationFrame ||\n        function (fn) {\n            return globalWindow.setTimeout(fn, 20);\n        };\n\n    var cancelAnimationFrame = globalWindow.cancelAnimationFrame ||\n        globalWindow.mozCancelAnimationFrame ||\n        globalWindow.webkitCancelAnimationFrame ||\n        function (timer) {\n            globalWindow.clearTimeout(timer);\n        };\n\n    /**\n     * Iterate over each of the provided element(s).\n     *\n     * @param {HTMLElement|HTMLElement[]} elements\n     * @param {Function}                  callback\n     */\n    function forEachElement(elements, callback){\n        var elementsType = Object.prototype.toString.call(elements);\n        var isCollectionTyped = ('[object Array]' === elementsType\n            || ('[object NodeList]' === elementsType)\n            || ('[object HTMLCollection]' === elementsType)\n            || ('[object Object]' === elementsType)\n            || ('undefined' !== typeof jQuery && elements instanceof jQuery) //jquery\n            || ('undefined' !== typeof Elements && elements instanceof Elements) //mootools\n        );\n        var i = 0, j = elements.length;\n        if (isCollectionTyped) {\n            for (; i < j; i++) {\n                callback(elements[i]);\n            }\n        } else {\n            callback(elements);\n        }\n    }\n\n    /**\n    * Get element size\n    * @param {HTMLElement} element\n    * @returns {Object} {width, height}\n    */\n    function getElementSize(element) {\n        if (!element.getBoundingClientRect) {\n            return {\n                width: element.offsetWidth,\n                height: element.offsetHeight\n            }\n        }\n\n        var rect = element.getBoundingClientRect();\n        return {\n            width: Math.round(rect.width),\n            height: Math.round(rect.height)\n        }\n    }\n\n    /**\n     * Apply CSS styles to element.\n     *\n     * @param {HTMLElement} element\n     * @param {Object} style\n     */\n    function setStyle(element, style) {\n        Object.keys(style).forEach(function(key) {\n            element.style[key] = style[key];\n        });\n    }\n\n    /**\n     * Class for dimension change detection.\n     *\n     * @param {Element|Element[]|Elements|jQuery} element\n     * @param {Function} callback\n     *\n     * @constructor\n     */\n    var ResizeSensor = function(element, callback) {\n        //Is used when checking in reset() only for invisible elements\n        var lastAnimationFrameForInvisibleCheck = 0;\n\n        /**\n         *\n         * @constructor\n         */\n        function EventQueue() {\n            var q = [];\n            this.add = function(ev) {\n                q.push(ev);\n            };\n\n            var i, j;\n            this.call = function(sizeInfo) {\n                for (i = 0, j = q.length; i < j; i++) {\n                    q[i].call(this, sizeInfo);\n                }\n            };\n\n            this.remove = function(ev) {\n                var newQueue = [];\n                for(i = 0, j = q.length; i < j; i++) {\n                    if(q[i] !== ev) newQueue.push(q[i]);\n                }\n                q = newQueue;\n            };\n\n            this.length = function() {\n                return q.length;\n            }\n        }\n\n        /**\n         *\n         * @param {HTMLElement} element\n         * @param {Function}    resized\n         */\n        function attachResizeEvent(element, resized) {\n            if (!element) return;\n            if (element.resizedAttached) {\n                element.resizedAttached.add(resized);\n                return;\n            }\n\n            element.resizedAttached = new EventQueue();\n            element.resizedAttached.add(resized);\n\n            element.resizeSensor = document.createElement('div');\n            element.resizeSensor.dir = 'ltr';\n            element.resizeSensor.className = 'resize-sensor';\n\n            var style = {\n                pointerEvents: 'none',\n                position: 'absolute',\n                left: '0px',\n                top: '0px',\n                right: '0px',\n                bottom: '0px',\n                overflow: 'hidden',\n                zIndex: '-1',\n                visibility: 'hidden',\n                maxWidth: '100%'\n            };\n            var styleChild = {\n                position: 'absolute',\n                left: '0px',\n                top: '0px',\n                transition: '0s',\n            };\n\n            setStyle(element.resizeSensor, style);\n\n            var expand = document.createElement('div');\n            expand.className = 'resize-sensor-expand';\n            setStyle(expand, style);\n\n            var expandChild = document.createElement('div');\n            setStyle(expandChild, styleChild);\n            expand.appendChild(expandChild);\n\n            var shrink = document.createElement('div');\n            shrink.className = 'resize-sensor-shrink';\n            setStyle(shrink, style);\n\n            var shrinkChild = document.createElement('div');\n            setStyle(shrinkChild, styleChild);\n            setStyle(shrinkChild, { width: '200%', height: '200%' });\n            shrink.appendChild(shrinkChild);\n\n            element.resizeSensor.appendChild(expand);\n            element.resizeSensor.appendChild(shrink);\n            element.appendChild(element.resizeSensor);\n\n            var computedStyle = window.getComputedStyle(element);\n            var position = computedStyle ? computedStyle.getPropertyValue('position') : null;\n            if ('absolute' !== position && 'relative' !== position && 'fixed' !== position && 'sticky' !== position) {\n                element.style.position = 'relative';\n            }\n\n            var dirty = false;\n\n            //last request animation frame id used in onscroll event\n            var rafId = 0;\n            var size = getElementSize(element);\n            var lastWidth = 0;\n            var lastHeight = 0;\n            var initialHiddenCheck = true;\n            lastAnimationFrameForInvisibleCheck = 0;\n\n            var resetExpandShrink = function () {\n                var width = element.offsetWidth;\n                var height = element.offsetHeight;\n\n                expandChild.style.width = (width + 10) + 'px';\n                expandChild.style.height = (height + 10) + 'px';\n\n                expand.scrollLeft = width + 10;\n                expand.scrollTop = height + 10;\n\n                shrink.scrollLeft = width + 10;\n                shrink.scrollTop = height + 10;\n            };\n\n            var reset = function() {\n                // Check if element is hidden\n                if (initialHiddenCheck) {\n                    var invisible = element.offsetWidth === 0 && element.offsetHeight === 0;\n                    if (invisible) {\n                        // Check in next frame\n                        if (!lastAnimationFrameForInvisibleCheck){\n                            lastAnimationFrameForInvisibleCheck = requestAnimationFrame(function(){\n                                lastAnimationFrameForInvisibleCheck = 0;\n                                reset();\n                            });\n                        }\n\n                        return;\n                    } else {\n                        // Stop checking\n                        initialHiddenCheck = false;\n                    }\n                }\n\n                resetExpandShrink();\n            };\n            element.resizeSensor.resetSensor = reset;\n\n            var onResized = function() {\n                rafId = 0;\n\n                if (!dirty) return;\n\n                lastWidth = size.width;\n                lastHeight = size.height;\n\n                if (element.resizedAttached) {\n                    element.resizedAttached.call(size);\n                }\n            };\n\n            var onScroll = function() {\n                size = getElementSize(element);\n                dirty = size.width !== lastWidth || size.height !== lastHeight;\n\n                if (dirty && !rafId) {\n                    rafId = requestAnimationFrame(onResized);\n                }\n\n                reset();\n            };\n\n            var addEvent = function(el, name, cb) {\n                if (el.attachEvent) {\n                    el.attachEvent('on' + name, cb);\n                } else {\n                    el.addEventListener(name, cb);\n                }\n            };\n\n            addEvent(expand, 'scroll', onScroll);\n            addEvent(shrink, 'scroll', onScroll);\n\n            // Fix for custom Elements and invisible elements\n            lastAnimationFrameForInvisibleCheck = requestAnimationFrame(function(){\n                lastAnimationFrameForInvisibleCheck = 0;\n                reset();\n            });\n        }\n\n        forEachElement(element, function(elem){\n            attachResizeEvent(elem, callback);\n        });\n\n        this.detach = function(ev) {\n            // clean up the unfinished animation frame to prevent a potential endless requestAnimationFrame of reset\n            if (!lastAnimationFrameForInvisibleCheck) {\n                cancelAnimationFrame(lastAnimationFrameForInvisibleCheck);\n                lastAnimationFrameForInvisibleCheck = 0;\n            }\n            ResizeSensor.detach(element, ev);\n        };\n\n        this.reset = function() {\n            element.resizeSensor.resetSensor();\n        };\n    };\n\n    ResizeSensor.reset = function(element) {\n        forEachElement(element, function(elem){\n            elem.resizeSensor.resetSensor();\n        });\n    };\n\n    ResizeSensor.detach = function(element, ev) {\n        forEachElement(element, function(elem){\n            if (!elem) return;\n            if(elem.resizedAttached && typeof ev === \"function\"){\n                elem.resizedAttached.remove(ev);\n                if(elem.resizedAttached.length()) return;\n            }\n            if (elem.resizeSensor) {\n                if (elem.contains(elem.resizeSensor)) {\n                    elem.removeChild(elem.resizeSensor);\n                }\n                delete elem.resizeSensor;\n                delete elem.resizedAttached;\n            }\n        });\n    };\n\n    if (typeof MutationObserver !== \"undefined\") {\n        var observer = new MutationObserver(function (mutations) {\n            for (var i in mutations) {\n                if (mutations.hasOwnProperty(i)) {\n                    var items = mutations[i].addedNodes;\n                    for (var j = 0; j < items.length; j++) {\n                        if (items[j].resizeSensor) {\n                            ResizeSensor.reset(items[j]);\n                        }\n                    }\n                }\n            }\n        });\n\n        document.addEventListener(\"DOMContentLoaded\", function (event) {\n            observer.observe(document.body, {\n                childList: true,\n                subtree: true,\n            });\n        });\n    }\n\n    return ResizeSensor;\n\n}));\n","/**\r\n * Sticky Sidebar JavaScript Plugin.\r\n * @version 3.3.1\r\n * @author Ahmed Bouhuolia <a.bouhuolia@gmail.com>\r\n * @license The MIT License (MIT)\r\n */\r\nconst StickySidebar = (() => {\r\n  \r\n    // ---------------------------------\r\n    // # Define Constants\r\n    // ---------------------------------\r\n    //\r\n    const EVENT_KEY = '.stickySidebar';\r\n    const VERSION   = '3.3.1';\r\n  \r\n    const DEFAULTS = {\r\n      \r\n      /**\r\n       * Additional top spacing of the element when it becomes sticky.\r\n       * @type {Numeric|Function}\r\n       */\r\n      topSpacing: 0,\r\n  \r\n      /**\r\n       * Additional bottom spacing of the element when it becomes sticky.\r\n       * @type {Numeric|Function}\r\n       */\r\n      bottomSpacing: 0,\r\n  \r\n      /**\r\n       * Container sidebar selector to know what the beginning and end of sticky element.\r\n       * @type {String|False}\r\n       */\r\n      containerSelector: false,\r\n  \r\n      /**\r\n       * Inner wrapper selector.\r\n       * @type {String}\r\n       */\r\n      innerWrapperSelector: '.inner-wrapper-sticky',\r\n  \r\n      /**\r\n       * The name of CSS class to apply to elements when they have become stuck.\r\n       * @type {String|False}\r\n       */\r\n      stickyClass: 'is-affixed',\r\n  \r\n      /**\r\n       * Detect when sidebar and its container change height so re-calculate their dimensions.\r\n       * @type {Boolean}\r\n       */\r\n      resizeSensor: true,\r\n  \r\n      /**\r\n       * The sidebar returns to its normal position if its width below this value.\r\n       * @type {Numeric}\r\n       */\r\n      minWidth: false\r\n    };\r\n  \r\n    // ---------------------------------\r\n    // # Class Definition\r\n    // ---------------------------------\r\n    //\r\n    /**\r\n     * Sticky Sidebar Class.\r\n     * @public\r\n     */\r\n    class StickySidebar{\r\n  \r\n      /**\r\n       * Sticky Sidebar Constructor.\r\n       * @constructor\r\n       * @param {HTMLElement|String} sidebar - The sidebar element or sidebar selector.\r\n       * @param {Object} options - The options of sticky sidebar.\r\n       */\r\n      constructor(sidebar, options = {}){\r\n        this.options = StickySidebar.extend(DEFAULTS, options);\r\n  \r\n        // Sidebar element query if there's no one, throw error.\r\n        this.sidebar = ('string' === typeof sidebar ) ? document.querySelector(sidebar) : sidebar;\r\n        if( 'undefined' === typeof this.sidebar )\r\n          throw new Error(\"There is no specific sidebar element.\");\r\n  \r\n        this.sidebarInner = false;\r\n        this.container = this.sidebar.parentElement;\r\n  \r\n        // Current Affix Type of sidebar element.\r\n        this.affixedType = 'STATIC';\r\n        this.direction = 'down';\r\n        this.support = {\r\n          transform:   false,\r\n          transform3d: false\r\n        };\r\n  \r\n        this._initialized = false;\r\n        this._reStyle = false;\r\n        this._breakpoint = false;\r\n        this._resizeListeners = [];\r\n        \r\n        // Dimensions of sidebar, container and screen viewport.\r\n        this.dimensions = {\r\n          translateY: 0,\r\n          topSpacing: 0,\r\n          lastTopSpacing: 0,\r\n          bottomSpacing: 0,\r\n          lastBottomSpacing: 0,\r\n          sidebarHeight: 0,\r\n          sidebarWidth: 0,\r\n          containerTop: 0,\r\n          containerHeight: 0,\r\n          viewportHeight: 0,\r\n          viewportTop: 0, \r\n          lastViewportTop: 0,\r\n        };\r\n  \r\n        // Bind event handlers for referencability.\r\n        ['handleEvent'].forEach( (method) => {\r\n          this[method] = this[method].bind(this);\r\n        });\r\n  \r\n        // Initialize sticky sidebar for first time.\r\n        this.initialize();\r\n      }\r\n  \r\n      /**\r\n       * Initializes the sticky sidebar by adding inner wrapper, define its container, \r\n       * min-width breakpoint, calculating dimensions, adding helper classes and inline style.\r\n       * @private\r\n       */\r\n      initialize(){\r\n        this._setSupportFeatures();\r\n  \r\n        // Get sticky sidebar inner wrapper, if not found, will create one.\r\n        if( this.options.innerWrapperSelector ){\r\n          this.sidebarInner = this.sidebar.querySelector(this.options.innerWrapperSelector);\r\n  \r\n          if( null === this.sidebarInner )\r\n            this.sidebarInner = false;\r\n        }\r\n        \r\n        if( ! this.sidebarInner ){\r\n          let wrapper = document.createElement('div');\r\n          wrapper.setAttribute('class', 'inner-wrapper-sticky');\r\n          this.sidebar.appendChild(wrapper);\r\n  \r\n          while( this.sidebar.firstChild != wrapper )\r\n            wrapper.appendChild(this.sidebar.firstChild);\r\n  \r\n          this.sidebarInner = this.sidebar.querySelector('.inner-wrapper-sticky');\r\n        }\r\n  \r\n        // Container wrapper of the sidebar.\r\n        if( this.options.containerSelector ){\r\n          let containers = document.querySelectorAll(this.options.containerSelector);\r\n          containers = Array.prototype.slice.call(containers);\r\n  \r\n          containers.forEach((container, item) => {\r\n            if( ! container.contains(this.sidebar) ) return;\r\n            this.container = container;\r\n          });\r\n  \r\n          if( ! containers.length )\r\n            throw new Error(\"The container does not contains on the sidebar.\");\r\n        }\r\n        \r\n        // If top/bottom spacing is not function parse value to integer.\r\n        if( 'function' !== typeof this.options.topSpacing )\r\n          this.options.topSpacing = parseInt(this.options.topSpacing) || 0;\r\n  \r\n        if( 'function' !== typeof this.options.bottomSpacing )\r\n          this.options.bottomSpacing = parseInt(this.options.bottomSpacing) || 0;\r\n            \r\n        // Breakdown sticky sidebar if screen width below `options.minWidth`.\r\n        this._widthBreakpoint();\r\n  \r\n        // Calculate dimensions of sidebar, container and viewport.\r\n        this.calcDimensions();\r\n  \r\n        // Affix sidebar in proper position.\r\n        this.stickyPosition();\r\n  \r\n        // Bind all events.\r\n        this.bindEvents();\r\n        \r\n        // Inform other properties the sticky sidebar is initialized.\r\n        this._initialized = true;\r\n      }\r\n  \r\n      /**\r\n       * Bind all events of sticky sidebar plugin.\r\n       * @protected\r\n       */\r\n      bindEvents(){\r\n        window.addEventListener('resize', this, {passive: true, capture: false});\r\n        window.addEventListener('scroll', this, {passive: true, capture: false});\r\n  \r\n        this.sidebar.addEventListener('update' + EVENT_KEY, this);\r\n  \r\n        if( this.options.resizeSensor && 'undefined' !== typeof ResizeSensor ){\r\n          new ResizeSensor(this.sidebarInner, this.handleEvent);\r\n          new ResizeSensor(this.container, this.handleEvent);\r\n        }\r\n      }\r\n  \r\n      /**\r\n       * Handles all events of the plugin.\r\n       * @param {Object} event - Event object passed from listener.\r\n       */\r\n      handleEvent(event){\r\n        this.updateSticky(event);\r\n      }\r\n  \r\n      /**\r\n       * Calculates dimensions of sidebar, container and screen viewpoint\r\n       * @public\r\n       */\r\n      calcDimensions(){\r\n        if( this._breakpoint ) return;\r\n        var dims = this.dimensions;\r\n  \r\n        // Container of sticky sidebar dimensions.\r\n        dims.containerTop    = StickySidebar.offsetRelative(this.container).top;\r\n        dims.containerHeight = this.container.clientHeight;\r\n        dims.containerBottom = dims.containerTop + dims.containerHeight;\r\n  \r\n        // Sidebar dimensions.\r\n        dims.sidebarHeight = this.sidebarInner.offsetHeight;\r\n        dims.sidebarWidth  = this.sidebar.offsetWidth;\r\n        \r\n        // Screen viewport dimensions.\r\n        dims.viewportHeight = window.innerHeight;\r\n  \r\n        this._calcDimensionsWithScroll();\r\n      }\r\n  \r\n      /**\r\n       * Some dimensions values need to be up-to-date when scrolling the page.\r\n       * @private\r\n       */\r\n      _calcDimensionsWithScroll(){\r\n        var dims = this.dimensions;\r\n  \r\n        dims.sidebarLeft = StickySidebar.offsetRelative(this.sidebar).left;\r\n  \r\n        dims.viewportTop    = document.documentElement.scrollTop || document.body.scrollTop;\r\n        dims.viewportBottom = dims.viewportTop + dims.viewportHeight;\r\n        dims.viewportLeft   = document.documentElement.scrollLeft || document.body.scrollLeft;\r\n  \r\n        dims.topSpacing    = this.options.topSpacing;\r\n        dims.bottomSpacing = this.options.bottomSpacing;\r\n  \r\n        if( 'function' === typeof dims.topSpacing )\r\n            dims.topSpacing = parseInt(dims.topSpacing(this.sidebar)) || 0;\r\n  \r\n        if( 'function' === typeof dims.bottomSpacing )\r\n            dims.bottomSpacing = parseInt(dims.bottomSpacing(this.sidebar)) || 0;\r\n        \r\n        if( 'VIEWPORT-TOP' === this.affixedType ){\r\n          // Adjust translate Y in the case decrease top spacing value.\r\n          if( dims.topSpacing < dims.lastTopSpacing ){\r\n            dims.translateY += dims.lastTopSpacing - dims.topSpacing;\r\n            this._reStyle = true; \r\n          }\r\n        \r\n        } else if( 'VIEWPORT-BOTTOM' === this.affixedType ){\r\n          // Adjust translate Y in the case decrease bottom spacing value.\r\n          if( dims.bottomSpacing < dims.lastBottomSpacing ){\r\n            dims.translateY += dims.lastBottomSpacing - dims.bottomSpacing;\r\n            this._reStyle = true;\r\n          }\r\n        }\r\n        \r\n        dims.lastTopSpacing    = dims.topSpacing;\r\n        dims.lastBottomSpacing = dims.bottomSpacing;\r\n      }\r\n      \r\n      /**\r\n       * Determine whether the sidebar is bigger than viewport.\r\n       * @public\r\n       * @return {Boolean}\r\n       */\r\n      isSidebarFitsViewport(){\r\n        return this.dimensions.sidebarHeight < this.dimensions.viewportHeight;\r\n      }\r\n  \r\n      /**\r\n       * Observe browser scrolling direction top and down.\r\n       */\r\n      observeScrollDir(){\r\n        var dims = this.dimensions;\r\n        if( dims.lastViewportTop === dims.viewportTop ) return;\r\n  \r\n        var furthest = 'down' === this.direction ? Math.min : Math.max;\r\n        \r\n        // If the browser is scrolling not in the same direction.\r\n        if( dims.viewportTop === furthest(dims.viewportTop, dims.lastViewportTop) )\r\n          this.direction = 'down' === this.direction ?  'up' : 'down';\r\n      }\r\n  \r\n      /**\r\n       * Gets affix type of sidebar according to current scrollTop and scrollLeft.\r\n       * Holds all logical affix of the sidebar when scrolling up and down and when sidebar \r\n       * is bigger than viewport and vice versa.\r\n       * @public\r\n       * @return {String|False} - Proper affix type.\r\n       */\r\n      getAffixType(){\r\n        var dims = this.dimensions, affixType = false;\r\n  \r\n        this._calcDimensionsWithScroll();\r\n  \r\n        var sidebarBottom = dims.sidebarHeight + dims.containerTop;\r\n        var colliderTop = dims.viewportTop + dims.topSpacing;\r\n        var colliderBottom = dims.viewportBottom - dims.bottomSpacing;\r\n  \r\n        // When browser is scrolling top.\r\n        if( 'up' === this.direction ){\r\n          if( colliderTop <= dims.containerTop ){\r\n            dims.translateY = 0;\r\n            affixType = 'STATIC';\r\n  \r\n          } else if( colliderTop <= dims.translateY + dims.containerTop ){\r\n            dims.translateY = colliderTop - dims.containerTop;\r\n            affixType = 'VIEWPORT-TOP';\r\n  \r\n          } else if( ! this.isSidebarFitsViewport() && dims.containerTop <= colliderTop ){\r\n            affixType = 'VIEWPORT-UNBOTTOM';\r\n          }\r\n        // When browser is scrolling up.\r\n        } else {\r\n          // When sidebar element is not bigger than screen viewport.\r\n          if( this.isSidebarFitsViewport() ){\r\n  \r\n            if( dims.sidebarHeight + colliderTop >= dims.containerBottom ){\r\n              dims.translateY = dims.containerBottom - sidebarBottom;\r\n              affixType = 'CONTAINER-BOTTOM'; \r\n  \r\n            } else if( colliderTop >= dims.containerTop ){\r\n              dims.translateY = colliderTop - dims.containerTop;\r\n              affixType = 'VIEWPORT-TOP';\r\n            }\r\n          // When sidebar element is bigger than screen viewport.\r\n          } else {\r\n      \r\n            if( dims.containerBottom <= colliderBottom ){\r\n              dims.translateY = dims.containerBottom - sidebarBottom; \r\n              affixType = 'CONTAINER-BOTTOM';    \r\n  \r\n            } else if( sidebarBottom + dims.translateY <= colliderBottom ){\r\n              dims.translateY = colliderBottom - sidebarBottom;\r\n              affixType = 'VIEWPORT-BOTTOM';\r\n            \r\n            } else if( dims.containerTop + dims.translateY <= colliderTop ){\r\n              affixType = 'VIEWPORT-UNBOTTOM';\r\n            }\r\n          }\r\n        }\r\n  \r\n        // Make sure the translate Y is not bigger than container height.\r\n        dims.translateY = Math.max(0, dims.translateY);\r\n        dims.translateY = Math.min(dims.containerHeight, dims.translateY);\r\n  \r\n        dims.lastViewportTop = dims.viewportTop;\r\n        return affixType;\r\n      }\r\n  \r\n      /**\r\n       * Gets inline style of sticky sidebar wrapper and inner wrapper according \r\n       * to its affix type.\r\n       * @private\r\n       * @param {String} affixType - Affix type of sticky sidebar.\r\n       * @return {Object}\r\n       */\r\n      _getStyle(affixType){\r\n        if( 'undefined' === typeof affixType ) return;\r\n  \r\n        var style = {inner: {}, outer: {}};\r\n        var dims = this.dimensions;\r\n  \r\n        switch( affixType ){\r\n          case 'VIEWPORT-TOP':\r\n            style.inner = {position: 'fixed', top: dims.topSpacing,\r\n                  left: dims.sidebarLeft - dims.viewportLeft, width: dims.sidebarWidth};\r\n            break;\r\n          case 'VIEWPORT-BOTTOM':\r\n            style.inner = {position: 'fixed', top: 'auto', left: dims.sidebarLeft,\r\n                  bottom: dims.bottomSpacing, width: dims.sidebarWidth};\r\n            break;\r\n          case 'CONTAINER-BOTTOM':\r\n          case 'VIEWPORT-UNBOTTOM':\r\n            let translate = this._getTranslate(0, dims.translateY + 'px');\r\n            \r\n            if( translate )\r\n              style.inner = {transform: translate};\r\n            else \r\n              style.inner = {position: 'absolute', top: dims.translateY, width: dims.sidebarWidth};\r\n            break;\r\n        }\r\n        \r\n        switch( affixType ){\r\n          case 'VIEWPORT-TOP':\r\n          case 'VIEWPORT-BOTTOM':\r\n          case 'VIEWPORT-UNBOTTOM':\r\n          case 'CONTAINER-BOTTOM':\r\n            style.outer = {height: dims.sidebarHeight, position: 'relative'};\r\n            break;\r\n        }\r\n  \r\n        style.outer = StickySidebar.extend({height: '', position: ''}, style.outer);\r\n        style.inner = StickySidebar.extend({position: 'relative', top: '', left: '',\r\n            bottom: '', width: '',  transform: this._getTranslate()}, style.inner);\r\n  \r\n        return style;\r\n      }\r\n     \r\n      /**\r\n       * Cause the sidebar to be sticky according to affix type by adding inline\r\n       * style, adding helper class and trigger events.\r\n       * @function\r\n       * @protected\r\n       * @param {string} force - Update sticky sidebar position by force.\r\n       */\r\n      stickyPosition(force){\r\n        if( this._breakpoint ) return;\r\n  \r\n        force = this._reStyle || force || false;\r\n        \r\n        var offsetTop = this.options.topSpacing;\r\n        var offsetBottom = this.options.bottomSpacing;\r\n  \r\n        var affixType = this.getAffixType();\r\n        var style = this._getStyle(affixType);\r\n        \r\n        if( (this.affixedType != affixType || force) && affixType ){\r\n          let affixEvent = 'affix.' + affixType.toLowerCase().replace('viewport-', '') + EVENT_KEY;\r\n          StickySidebar.eventTrigger(this.sidebar, affixEvent);\r\n  \r\n          if( 'STATIC' === affixType )\r\n            StickySidebar.removeClass(this.sidebar, this.options.stickyClass);\r\n          else\r\n            StickySidebar.addClass(this.sidebar, this.options.stickyClass);\r\n          \r\n          for( let key in style.outer ){\r\n            let _unit = ('number' === typeof style.outer[key]) ? 'px' : '';\r\n            this.sidebar.style[key] = style.outer[key];\r\n          }\r\n  \r\n          for( let key in style.inner ){\r\n            let _unit = ('number' === typeof style.inner[key]) ? 'px' : '';\r\n            this.sidebarInner.style[key] = style.inner[key] + _unit;\r\n          }\r\n          \r\n          let affixedEvent = 'affixed.'+ affixType.toLowerCase().replace('viewport-', '') + EVENT_KEY;\r\n          StickySidebar.eventTrigger(this.sidebar, affixedEvent);\r\n        } else {\r\n          if( this._initialized ) this.sidebarInner.style.left = style.inner.left;\r\n        }\r\n  \r\n        this.affixedType = affixType;\r\n      }\r\n  \r\n      /**\r\n       * Breakdown sticky sidebar when window width is below `options.minWidth` value.\r\n       * @protected\r\n       */\r\n      _widthBreakpoint(){\r\n  \r\n        if( window.innerWidth <= this.options.minWidth ){\r\n          this._breakpoint = true;\r\n          this.affixedType = 'STATIC';\r\n  \r\n          this.sidebar.removeAttribute('style');\r\n          StickySidebar.removeClass(this.sidebar, this.options.stickyClass);\r\n          this.sidebarInner.removeAttribute('style');\r\n        } else {\r\n          this._breakpoint = false;\r\n        }\r\n      }\r\n  \r\n      /**\r\n       * Switches between functions stack for each event type, if there's no \r\n       * event, it will re-initialize sticky sidebar.\r\n       * @public\r\n       */\r\n      updateSticky(event = {}){\r\n        if( this._running ) return;\r\n        this._running = true;\r\n  \r\n        ((eventType) => {\r\n\r\n          requestAnimationFrame(() => {\r\n            switch( eventType ){\r\n              // When browser is scrolling and re-calculate just dimensions\r\n              // within scroll. \r\n              case 'scroll':\r\n                this._calcDimensionsWithScroll();\r\n                this.observeScrollDir();\r\n                this.stickyPosition();\r\n                break;\r\n  \r\n              // When browser is resizing or there's no event, observe width\r\n              // breakpoint and re-calculate dimensions.\r\n              case 'resize':\r\n              default: \r\n                this._widthBreakpoint();\r\n                this.calcDimensions();\r\n                this.stickyPosition(true);\r\n                break;\r\n            }\r\n            this._running = false;\r\n          });\r\n        })(event.type);\r\n      }\r\n  \r\n      /**\r\n       * Set browser support features to the public property.\r\n       * @private\r\n       */\r\n      _setSupportFeatures(){\r\n        var support = this.support;\r\n  \r\n        support.transform = StickySidebar.supportTransform();\r\n        support.transform3d = StickySidebar.supportTransform(true);\r\n      }\r\n  \r\n      /**\r\n       * Get translate value, if the browser supports transfrom3d, it will adopt it.\r\n       * and the same with translate. if browser doesn't support both return false.\r\n       * @param {Number} y - Value of Y-axis.\r\n       * @param {Number} x - Value of X-axis.\r\n       * @param {Number} z - Value of Z-axis.\r\n       * @return {String|False}\r\n       */\r\n      _getTranslate(y = 0, x = 0, z = 0){\r\n        if( this.support.transform3d ) return 'translate3d(' + y +', '+ x +', '+ z +')';\r\n        else if( this.support.translate ) return 'translate('+ y +', '+ x +')';\r\n        else return false;\r\n      }\r\n  \r\n      /**\r\n       * Destroy sticky sidebar plugin.\r\n       * @public\r\n       */\r\n      destroy(){\r\n        window.removeEventListener('resize', this, {caption: false});\r\n        window.removeEventListener('scroll', this, {caption: false});\r\n  \r\n        this.sidebar.classList.remove(this.options.stickyClass);\r\n        this.sidebar.style.minHeight = '';\r\n  \r\n        this.sidebar.removeEventListener('update' + EVENT_KEY, this);\r\n  \r\n        var styleReset = {inner: {}, outer: {}};\r\n  \r\n        styleReset.inner = {position: '', top: '', left: '', bottom: '', width: '',  transform: ''};\r\n        styleReset.outer = {height: '', position: ''};\r\n  \r\n        for( let key in styleReset.outer )\r\n          this.sidebar.style[key] = styleReset.outer[key];\r\n  \r\n        for( let key in styleReset.inner )\r\n          this.sidebarInner.style[key] = styleReset.inner[key];\r\n  \r\n        if( this.options.resizeSensor && 'undefined' !== typeof ResizeSensor ){\r\n          ResizeSensor.detach(this.sidebarInner, this.handleEvent);\r\n          ResizeSensor.detach(this.container, this.handleEvent);\r\n        }\r\n      }\r\n  \r\n      /**\r\n       * Determine if the browser supports CSS transform feature.\r\n       * @function\r\n       * @static\r\n       * @param {Boolean} transform3d - Detect transform with translate3d.\r\n       * @return {String}\r\n       */\r\n      static supportTransform(transform3d){\r\n        var result = false,\r\n            property = (transform3d) ? 'perspective' : 'transform',\r\n            upper = property.charAt(0).toUpperCase() + property.slice(1),\r\n            prefixes = ['Webkit', 'Moz', 'O', 'ms'],\r\n            support = document.createElement('support'),\r\n            style = support.style;\r\n  \r\n        (property + ' ' + prefixes.join(upper + ' ') + upper).split(' ').forEach(function(property, i) {\r\n          if (style[property] !== undefined) {\r\n            result = property;\r\n            return false;\r\n          }\r\n        });\r\n        return result;\r\n      }\r\n  \r\n      /**\r\n       * Trigger custom event.\r\n       * @static\r\n       * @param {DOMObject} element - Target element on the DOM.\r\n       * @param {String} eventName - Event name.\r\n       * @param {Object} data - \r\n       */\r\n      static eventTrigger(element, eventName, data){\r\n        try{\r\n          var event = new CustomEvent(eventName, {detail: data});\r\n        } catch(e){\r\n          var event = document.createEvent('CustomEvent');\r\n          event.initCustomEvent(eventName, true, true, data);\r\n        }\r\n        element.dispatchEvent(event);\r\n      }\r\n  \r\n      /**\r\n       * Extend options object with defaults.\r\n       * @function\r\n       * @static\r\n       */\r\n      static extend(defaults, options){\r\n        var results = {};\r\n        for( let key in defaults ){\r\n          if( 'undefined' !== typeof options[key] ) results[key] = options[key];\r\n          else results[key] = defaults[key];\r\n        }\r\n        return results;\r\n      }\r\n  \r\n      /**\r\n       * Get current coordinates left and top of specific element.\r\n       * @static\r\n       */\r\n      static offsetRelative(element){\r\n        var result = {left: 0, top: 0};\r\n\r\n        do{\r\n          let offsetTop = element.offsetTop;\r\n          let offsetLeft = element.offsetLeft;\r\n  \r\n          if( ! isNaN(offsetTop) )\r\n            result.top += offsetTop;\r\n  \r\n          if( ! isNaN(offsetLeft) )\r\n            result.left += offsetLeft;\r\n\r\n          element = ( 'BODY' === element.tagName ) ?\r\n                      element.parentElement : element.offsetParent;\r\n        } while(element)\r\n        return result;\r\n      }\r\n  \r\n      /**\r\n       * Add specific class name to specific element.\r\n       * @static \r\n       * @param {ObjectDOM} element \r\n       * @param {String} className \r\n       */\r\n      static addClass(element, className){\r\n        if( ! StickySidebar.hasClass(element, className) ){\r\n          if (element.classList)\r\n            element.classList.add(className);\r\n          else\r\n            element.className += ' ' + className;\r\n        }\r\n      }\r\n      \r\n      /**\r\n       * Remove specific class name to specific element\r\n       * @static\r\n       * @param {ObjectDOM} element \r\n       * @param {String} className \r\n       */\r\n      static removeClass(element, className){\r\n        if( StickySidebar.hasClass(element, className) ){\r\n          if (element.classList)\r\n            element.classList.remove(className);\r\n          else\r\n            element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Determine weather the element has specific class name.\r\n       * @static\r\n       * @param {ObjectDOM} element \r\n       * @param {String} className \r\n       */\r\n      static hasClass(element, className){\r\n        if (element.classList)\r\n          return element.classList.contains(className);\r\n        else\r\n          return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);\r\n      }\r\n    }\r\n  \r\n    return StickySidebar;\r\n  })();\r\n  \r\n  export default StickySidebar;\r\n  \r\n  // Global\r\n  // -------------------------\r\n  window.StickySidebar = StickySidebar;","/*!\n * Glide.js v3.6.0\n * (c) 2013-2022 Jędrzej Chałubek (https://github.com/jedrzejchalubek/)\n * Released under the MIT License.\n */\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}\n\nvar defaults = {\n  /**\n   * Type of the movement.\n   *\n   * Available types:\n   * `slider` - Rewinds slider to the start/end when it reaches the first or last slide.\n   * `carousel` - Changes slides without starting over when it reaches the first or last slide.\n   *\n   * @type {String}\n   */\n  type: 'slider',\n\n  /**\n   * Start at specific slide number defined with zero-based index.\n   *\n   * @type {Number}\n   */\n  startAt: 0,\n\n  /**\n   * A number of slides visible on the single viewport.\n   *\n   * @type {Number}\n   */\n  perView: 1,\n\n  /**\n   * Focus currently active slide at a specified position in the track.\n   *\n   * Available inputs:\n   * `center` - Current slide will be always focused at the center of a track.\n   * `0,1,2,3...` - Current slide will be focused on the specified zero-based index.\n   *\n   * @type {String|Number}\n   */\n  focusAt: 0,\n\n  /**\n   * A size of the gap added between slides.\n   *\n   * @type {Number}\n   */\n  gap: 10,\n\n  /**\n   * Change slides after a specified interval. Use `false` for turning off autoplay.\n   *\n   * @type {Number|Boolean}\n   */\n  autoplay: false,\n\n  /**\n   * Stop autoplay on mouseover event.\n   *\n   * @type {Boolean}\n   */\n  hoverpause: true,\n\n  /**\n   * Allow for changing slides with left and right keyboard arrows.\n   *\n   * @type {Boolean}\n   */\n  keyboard: true,\n\n  /**\n   * Stop running `perView` number of slides from the end. Use this\n   * option if you don't want to have an empty space after\n   * a slider. Works only with `slider` type and a\n   * non-centered `focusAt` setting.\n   *\n   * @type {Boolean}\n   */\n  bound: false,\n\n  /**\n   * Minimal swipe distance needed to change the slide. Use `false` for turning off a swiping.\n   *\n   * @type {Number|Boolean}\n   */\n  swipeThreshold: 80,\n\n  /**\n   * Minimal mouse drag distance needed to change the slide. Use `false` for turning off a dragging.\n   *\n   * @type {Number|Boolean}\n   */\n  dragThreshold: 120,\n\n  /**\n   * A number of slides moved on single swipe.\n   *\n   * Available types:\n   * `` - Moves slider by one slide per swipe\n   * `|` - Moves slider between views per swipe (number of slides defined in `perView` options)\n   *\n   * @type {String}\n   */\n  perSwipe: '',\n\n  /**\n   * Moving distance ratio of the slides on a swiping and dragging.\n   *\n   * @type {Number}\n   */\n  touchRatio: 0.5,\n\n  /**\n   * Angle required to activate slides moving on swiping or dragging.\n   *\n   * @type {Number}\n   */\n  touchAngle: 45,\n\n  /**\n   * Duration of the animation in milliseconds.\n   *\n   * @type {Number}\n   */\n  animationDuration: 400,\n\n  /**\n   * Allows looping the `slider` type. Slider will rewind to the first/last slide when it's at the start/end.\n   *\n   * @type {Boolean}\n   */\n  rewind: true,\n\n  /**\n   * Duration of the rewinding animation of the `slider` type in milliseconds.\n   *\n   * @type {Number}\n   */\n  rewindDuration: 800,\n\n  /**\n   * Easing function for the animation.\n   *\n   * @type {String}\n   */\n  animationTimingFunc: 'cubic-bezier(.165, .840, .440, 1)',\n\n  /**\n   * Wait for the animation to finish until the next user input can be processed\n   *\n   * @type {boolean}\n   */\n  waitForTransition: true,\n\n  /**\n   * Throttle costly events at most once per every wait milliseconds.\n   *\n   * @type {Number}\n   */\n  throttle: 10,\n\n  /**\n   * Moving direction mode.\n   *\n   * Available inputs:\n   * - 'ltr' - left to right movement,\n   * - 'rtl' - right to left movement.\n   *\n   * @type {String}\n   */\n  direction: 'ltr',\n\n  /**\n   * The distance value of the next and previous viewports which\n   * have to peek in the current view. Accepts number and\n   * pixels as a string. Left and right peeking can be\n   * set up separately with a directions object.\n   *\n   * For example:\n   * `100` - Peek 100px on the both sides.\n   * { before: 100, after: 50 }` - Peek 100px on the left side and 50px on the right side.\n   *\n   * @type {Number|String|Object}\n   */\n  peek: 0,\n\n  /**\n   * Defines how many clones of current viewport will be generated.\n   *\n   * @type {Number}\n   */\n  cloningRatio: 1,\n\n  /**\n   * Collection of options applied at specified media breakpoints.\n   * For example: display two slides per view under 800px.\n   * `{\n   *   '800px': {\n   *     perView: 2\n   *   }\n   * }`\n   */\n  breakpoints: {},\n\n  /**\n   * Collection of internally used HTML classes.\n   *\n   * @todo Refactor `slider` and `carousel` properties to single `type: { slider: '', carousel: '' }` object\n   * @type {Object}\n   */\n  classes: {\n    swipeable: 'glide--swipeable',\n    dragging: 'glide--dragging',\n    direction: {\n      ltr: 'glide--ltr',\n      rtl: 'glide--rtl'\n    },\n    type: {\n      slider: 'glide--slider',\n      carousel: 'glide--carousel'\n    },\n    slide: {\n      clone: 'glide__slide--clone',\n      active: 'glide__slide--active'\n    },\n    arrow: {\n      disabled: 'glide__arrow--disabled'\n    },\n    nav: {\n      active: 'glide__bullet--active'\n    }\n  }\n};\n\n/**\n * Outputs warning message to the bowser console.\n *\n * @param  {String} msg\n * @return {Void}\n */\nfunction warn(msg) {\n  console.error(\"[Glide warn]: \".concat(msg));\n}\n\n/**\n * Converts value entered as number\n * or string to integer value.\n *\n * @param {String} value\n * @returns {Number}\n */\nfunction toInt(value) {\n  return parseInt(value);\n}\n/**\n * Converts value entered as number\n * or string to flat value.\n *\n * @param {String} value\n * @returns {Number}\n */\n\nfunction toFloat(value) {\n  return parseFloat(value);\n}\n/**\n * Indicates whether the specified value is a string.\n *\n * @param  {*}   value\n * @return {Boolean}\n */\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n/**\n * Indicates whether the specified value is an object.\n *\n * @param  {*} value\n * @return {Boolean}\n *\n * @see https://github.com/jashkenas/underscore\n */\n\nfunction isObject(value) {\n  var type = _typeof(value);\n\n  return type === 'function' || type === 'object' && !!value; // eslint-disable-line no-mixed-operators\n}\n/**\n * Indicates whether the specified value is a function.\n *\n * @param  {*} value\n * @return {Boolean}\n */\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * Indicates whether the specified value is undefined.\n *\n * @param  {*} value\n * @return {Boolean}\n */\n\nfunction isUndefined(value) {\n  return typeof value === 'undefined';\n}\n/**\n * Indicates whether the specified value is an array.\n *\n * @param  {*} value\n * @return {Boolean}\n */\n\nfunction isArray(value) {\n  return value.constructor === Array;\n}\n\n/**\n * Creates and initializes specified collection of extensions.\n * Each extension receives access to instance of glide and rest of components.\n *\n * @param {Object} glide\n * @param {Object} extensions\n *\n * @returns {Object}\n */\n\nfunction mount(glide, extensions, events) {\n  var components = {};\n\n  for (var name in extensions) {\n    if (isFunction(extensions[name])) {\n      components[name] = extensions[name](glide, components, events);\n    } else {\n      warn('Extension must be a function');\n    }\n  }\n\n  for (var _name in components) {\n    if (isFunction(components[_name].mount)) {\n      components[_name].mount();\n    }\n  }\n\n  return components;\n}\n\n/**\n * Defines getter and setter property on the specified object.\n *\n * @param  {Object} obj         Object where property has to be defined.\n * @param  {String} prop        Name of the defined property.\n * @param  {Object} definition  Get and set definitions for the property.\n * @return {Void}\n */\nfunction define(obj, prop, definition) {\n  Object.defineProperty(obj, prop, definition);\n}\n/**\n * Sorts aphabetically object keys.\n *\n * @param  {Object} obj\n * @return {Object}\n */\n\nfunction sortKeys(obj) {\n  return Object.keys(obj).sort().reduce(function (r, k) {\n    r[k] = obj[k];\n    return r[k], r;\n  }, {});\n}\n/**\n * Merges passed settings object with default options.\n *\n * @param  {Object} defaults\n * @param  {Object} settings\n * @return {Object}\n */\n\nfunction mergeOptions(defaults, settings) {\n  var options = Object.assign({}, defaults, settings); // `Object.assign` do not deeply merge objects, so we\n  // have to do it manually for every nested object\n  // in options. Although it does not look smart,\n  // it's smaller and faster than some fancy\n  // merging deep-merge algorithm script.\n\n  if (settings.hasOwnProperty('classes')) {\n    options.classes = Object.assign({}, defaults.classes, settings.classes);\n\n    if (settings.classes.hasOwnProperty('direction')) {\n      options.classes.direction = Object.assign({}, defaults.classes.direction, settings.classes.direction);\n    }\n\n    if (settings.classes.hasOwnProperty('type')) {\n      options.classes.type = Object.assign({}, defaults.classes.type, settings.classes.type);\n    }\n\n    if (settings.classes.hasOwnProperty('slide')) {\n      options.classes.slide = Object.assign({}, defaults.classes.slide, settings.classes.slide);\n    }\n\n    if (settings.classes.hasOwnProperty('arrow')) {\n      options.classes.arrow = Object.assign({}, defaults.classes.arrow, settings.classes.arrow);\n    }\n\n    if (settings.classes.hasOwnProperty('nav')) {\n      options.classes.nav = Object.assign({}, defaults.classes.nav, settings.classes.nav);\n    }\n  }\n\n  if (settings.hasOwnProperty('breakpoints')) {\n    options.breakpoints = Object.assign({}, defaults.breakpoints, settings.breakpoints);\n  }\n\n  return options;\n}\n\nvar EventsBus = /*#__PURE__*/function () {\n  /**\n   * Construct a EventBus instance.\n   *\n   * @param {Object} events\n   */\n  function EventsBus() {\n    var events = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, EventsBus);\n\n    this.events = events;\n    this.hop = events.hasOwnProperty;\n  }\n  /**\n   * Adds listener to the specifed event.\n   *\n   * @param {String|Array} event\n   * @param {Function} handler\n   */\n\n\n  _createClass(EventsBus, [{\n    key: \"on\",\n    value: function on(event, handler) {\n      if (isArray(event)) {\n        for (var i = 0; i < event.length; i++) {\n          this.on(event[i], handler);\n        }\n\n        return;\n      } // Create the event's object if not yet created\n\n\n      if (!this.hop.call(this.events, event)) {\n        this.events[event] = [];\n      } // Add the handler to queue\n\n\n      var index = this.events[event].push(handler) - 1; // Provide handle back for removal of event\n\n      return {\n        remove: function remove() {\n          delete this.events[event][index];\n        }\n      };\n    }\n    /**\n     * Runs registered handlers for specified event.\n     *\n     * @param {String|Array} event\n     * @param {Object=} context\n     */\n\n  }, {\n    key: \"emit\",\n    value: function emit(event, context) {\n      if (isArray(event)) {\n        for (var i = 0; i < event.length; i++) {\n          this.emit(event[i], context);\n        }\n\n        return;\n      } // If the event doesn't exist, or there's no handlers in queue, just leave\n\n\n      if (!this.hop.call(this.events, event)) {\n        return;\n      } // Cycle through events queue, fire!\n\n\n      this.events[event].forEach(function (item) {\n        item(context || {});\n      });\n    }\n  }]);\n\n  return EventsBus;\n}();\n\nvar Glide$1 = /*#__PURE__*/function () {\n  /**\r\n   * Construct glide.\r\n   *\r\n   * @param  {String} selector\r\n   * @param  {Object} options\r\n   */\n  function Glide(selector) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Glide);\n\n    this._c = {};\n    this._t = [];\n    this._e = new EventsBus();\n    this.disabled = false;\n    this.selector = selector;\n    this.settings = mergeOptions(defaults, options);\n    this.index = this.settings.startAt;\n  }\n  /**\r\n   * Initializes glide.\r\n   *\r\n   * @param {Object} extensions Collection of extensions to initialize.\r\n   * @return {Glide}\r\n   */\n\n\n  _createClass(Glide, [{\n    key: \"mount\",\n    value: function mount$1() {\n      var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._e.emit('mount.before');\n\n      if (isObject(extensions)) {\n        this._c = mount(this, extensions, this._e);\n      } else {\n        warn('You need to provide a object on `mount()`');\n      }\n\n      this._e.emit('mount.after');\n\n      return this;\n    }\n    /**\r\n     * Collects an instance `translate` transformers.\r\n     *\r\n     * @param  {Array} transformers Collection of transformers.\r\n     * @return {Void}\r\n     */\n\n  }, {\n    key: \"mutate\",\n    value: function mutate() {\n      var transformers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (isArray(transformers)) {\n        this._t = transformers;\n      } else {\n        warn('You need to provide a array on `mutate()`');\n      }\n\n      return this;\n    }\n    /**\r\n     * Updates glide with specified settings.\r\n     *\r\n     * @param {Object} settings\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.settings = mergeOptions(this.settings, settings);\n\n      if (settings.hasOwnProperty('startAt')) {\n        this.index = settings.startAt;\n      }\n\n      this._e.emit('update');\n\n      return this;\n    }\n    /**\r\n     * Change slide with specified pattern. A pattern must be in the special format:\r\n     * `>` - Move one forward\r\n     * `<` - Move one backward\r\n     * `={i}` - Go to {i} zero-based slide (eq. '=1', will go to second slide)\r\n     * `>>` - Rewinds to end (last slide)\r\n     * `<<` - Rewinds to start (first slide)\r\n     * `|>` - Move one viewport forward\r\n     * `|<` - Move one viewport backward\r\n     *\r\n     * @param {String} pattern\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"go\",\n    value: function go(pattern) {\n      this._c.Run.make(pattern);\n\n      return this;\n    }\n    /**\r\n     * Move track by specified distance.\r\n     *\r\n     * @param {String} distance\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"move\",\n    value: function move(distance) {\n      this._c.Transition.disable();\n\n      this._c.Move.make(distance);\n\n      return this;\n    }\n    /**\r\n     * Destroy instance and revert all changes done by this._c.\r\n     *\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._e.emit('destroy');\n\n      return this;\n    }\n    /**\r\n     * Start instance autoplaying.\r\n     *\r\n     * @param {Boolean|Number} interval Run autoplaying with passed interval regardless of `autoplay` settings\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"play\",\n    value: function play() {\n      var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (interval) {\n        this.settings.autoplay = interval;\n      }\n\n      this._e.emit('play');\n\n      return this;\n    }\n    /**\r\n     * Stop instance autoplaying.\r\n     *\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this._e.emit('pause');\n\n      return this;\n    }\n    /**\r\n     * Sets glide into a idle status.\r\n     *\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.disabled = true;\n      return this;\n    }\n    /**\r\n     * Sets glide into a active status.\r\n     *\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      this.disabled = false;\n      return this;\n    }\n    /**\r\n     * Adds cuutom event listener with handler.\r\n     *\r\n     * @param  {String|Array} event\r\n     * @param  {Function} handler\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(event, handler) {\n      this._e.on(event, handler);\n\n      return this;\n    }\n    /**\r\n     * Checks if glide is a precised type.\r\n     *\r\n     * @param  {String} name\r\n     * @return {Boolean}\r\n     */\n\n  }, {\n    key: \"isType\",\n    value: function isType(name) {\n      return this.settings.type === name;\n    }\n    /**\r\n     * Gets value of the core options.\r\n     *\r\n     * @return {Object}\r\n     */\n\n  }, {\n    key: \"settings\",\n    get: function get() {\n      return this._o;\n    }\n    /**\r\n     * Sets value of the core options.\r\n     *\r\n     * @param  {Object} o\r\n     * @return {Void}\r\n     */\n    ,\n    set: function set(o) {\n      if (isObject(o)) {\n        this._o = o;\n      } else {\n        warn('Options must be an `object` instance.');\n      }\n    }\n    /**\r\n     * Gets current index of the slider.\r\n     *\r\n     * @return {Object}\r\n     */\n\n  }, {\n    key: \"index\",\n    get: function get() {\n      return this._i;\n    }\n    /**\r\n     * Sets current index a slider.\r\n     *\r\n     * @return {Object}\r\n     */\n    ,\n    set: function set(i) {\n      this._i = toInt(i);\n    }\n    /**\r\n     * Gets type name of the slider.\r\n     *\r\n     * @return {String}\r\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.settings.type;\n    }\n    /**\r\n     * Gets value of the idle status.\r\n     *\r\n     * @return {Boolean}\r\n     */\n\n  }, {\n    key: \"disabled\",\n    get: function get() {\n      return this._d;\n    }\n    /**\r\n     * Sets value of the idle status.\r\n     *\r\n     * @return {Boolean}\r\n     */\n    ,\n    set: function set(status) {\n      this._d = !!status;\n    }\n  }]);\n\n  return Glide;\n}();\n\nfunction Run (Glide, Components, Events) {\n  var Run = {\n    /**\n     * Initializes autorunning of the glide.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      this._o = false;\n    },\n\n    /**\n     * Makes glides running based on the passed moving schema.\n     *\n     * @param {String} move\n     */\n    make: function make(move) {\n      var _this = this;\n\n      if (!Glide.disabled) {\n        !Glide.settings.waitForTransition || Glide.disable();\n        this.move = move;\n        Events.emit('run.before', this.move);\n        this.calculate();\n        Events.emit('run', this.move);\n        Components.Transition.after(function () {\n          if (_this.isStart()) {\n            Events.emit('run.start', _this.move);\n          }\n\n          if (_this.isEnd()) {\n            Events.emit('run.end', _this.move);\n          }\n\n          if (_this.isOffset()) {\n            _this._o = false;\n            Events.emit('run.offset', _this.move);\n          }\n\n          Events.emit('run.after', _this.move);\n          Glide.enable();\n        });\n      }\n    },\n\n    /**\n     * Calculates current index based on defined move.\n     *\n     * @return {Number|Undefined}\n     */\n    calculate: function calculate() {\n      var move = this.move,\n          length = this.length;\n      var steps = move.steps,\n          direction = move.direction; // By default assume that size of view is equal to one slide\n\n      var viewSize = 1; // While direction is `=` we want jump to\n      // a specified index described in steps.\n\n      if (direction === '=') {\n        // Check if bound is true, \n        // as we want to avoid whitespaces.\n        if (Glide.settings.bound && toInt(steps) > length) {\n          Glide.index = length;\n          return;\n        }\n\n        Glide.index = steps;\n        return;\n      } // When pattern is equal to `>>` we want\n      // fast forward to the last slide.\n\n\n      if (direction === '>' && steps === '>') {\n        Glide.index = length;\n        return;\n      } // When pattern is equal to `<<` we want\n      // fast forward to the first slide.\n\n\n      if (direction === '<' && steps === '<') {\n        Glide.index = 0;\n        return;\n      } // pagination movement\n\n\n      if (direction === '|') {\n        viewSize = Glide.settings.perView || 1;\n      } // we are moving forward\n\n\n      if (direction === '>' || direction === '|' && steps === '>') {\n        var index = calculateForwardIndex(viewSize);\n\n        if (index > length) {\n          this._o = true;\n        }\n\n        Glide.index = normalizeForwardIndex(index, viewSize);\n        return;\n      } // we are moving backward\n\n\n      if (direction === '<' || direction === '|' && steps === '<') {\n        var _index = calculateBackwardIndex(viewSize);\n\n        if (_index < 0) {\n          this._o = true;\n        }\n\n        Glide.index = normalizeBackwardIndex(_index, viewSize);\n        return;\n      }\n\n      warn(\"Invalid direction pattern [\".concat(direction).concat(steps, \"] has been used\"));\n    },\n\n    /**\n     * Checks if we are on the first slide.\n     *\n     * @return {Boolean}\n     */\n    isStart: function isStart() {\n      return Glide.index <= 0;\n    },\n\n    /**\n     * Checks if we are on the last slide.\n     *\n     * @return {Boolean}\n     */\n    isEnd: function isEnd() {\n      return Glide.index >= this.length;\n    },\n\n    /**\n     * Checks if we are making a offset run.\n     *\n     * @param {String} direction\n     * @return {Boolean}\n     */\n    isOffset: function isOffset() {\n      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n      if (!direction) {\n        return this._o;\n      }\n\n      if (!this._o) {\n        return false;\n      } // did we view to the right?\n\n\n      if (direction === '|>') {\n        return this.move.direction === '|' && this.move.steps === '>';\n      } // did we view to the left?\n\n\n      if (direction === '|<') {\n        return this.move.direction === '|' && this.move.steps === '<';\n      }\n\n      return this.move.direction === direction;\n    },\n\n    /**\n     * Checks if bound mode is active\n     *\n     * @return {Boolean}\n     */\n    isBound: function isBound() {\n      return Glide.isType('slider') && Glide.settings.focusAt !== 'center' && Glide.settings.bound;\n    }\n  };\n  /**\n   * Returns index value to move forward/to the right\n   *\n   * @param viewSize\n   * @returns {Number}\n   */\n\n  function calculateForwardIndex(viewSize) {\n    var index = Glide.index;\n\n    if (Glide.isType('carousel')) {\n      return index + viewSize;\n    }\n\n    return index + (viewSize - index % viewSize);\n  }\n  /**\n   * Normalizes the given forward index based on glide settings, preventing it to exceed certain boundaries\n   *\n   * @param index\n   * @param length\n   * @param viewSize\n   * @returns {Number}\n   */\n\n\n  function normalizeForwardIndex(index, viewSize) {\n    var length = Run.length;\n\n    if (index <= length) {\n      return index;\n    }\n\n    if (Glide.isType('carousel')) {\n      return index - (length + 1);\n    }\n\n    if (Glide.settings.rewind) {\n      // bound does funny things with the length, therefor we have to be certain\n      // that we are on the last possible index value given by bound\n      if (Run.isBound() && !Run.isEnd()) {\n        return length;\n      }\n\n      return 0;\n    }\n\n    if (Run.isBound()) {\n      return length;\n    }\n\n    return Math.floor(length / viewSize) * viewSize;\n  }\n  /**\n   * Calculates index value to move backward/to the left\n   *\n   * @param viewSize\n   * @returns {Number}\n   */\n\n\n  function calculateBackwardIndex(viewSize) {\n    var index = Glide.index;\n\n    if (Glide.isType('carousel')) {\n      return index - viewSize;\n    } // ensure our back navigation results in the same index as a forward navigation\n    // to experience a homogeneous paging\n\n\n    var view = Math.ceil(index / viewSize);\n    return (view - 1) * viewSize;\n  }\n  /**\n   * Normalizes the given backward index based on glide settings, preventing it to exceed certain boundaries\n   *\n   * @param index\n   * @param length\n   * @param viewSize\n   * @returns {*}\n   */\n\n\n  function normalizeBackwardIndex(index, viewSize) {\n    var length = Run.length;\n\n    if (index >= 0) {\n      return index;\n    }\n\n    if (Glide.isType('carousel')) {\n      return index + (length + 1);\n    }\n\n    if (Glide.settings.rewind) {\n      // bound does funny things with the length, therefor we have to be certain\n      // that we are on first possible index value before we to rewind to the length given by bound\n      if (Run.isBound() && Run.isStart()) {\n        return length;\n      }\n\n      return Math.floor(length / viewSize) * viewSize;\n    }\n\n    return 0;\n  }\n\n  define(Run, 'move', {\n    /**\n     * Gets value of the move schema.\n     *\n     * @returns {Object}\n     */\n    get: function get() {\n      return this._m;\n    },\n\n    /**\n     * Sets value of the move schema.\n     *\n     * @returns {Object}\n     */\n    set: function set(value) {\n      var step = value.substr(1);\n      this._m = {\n        direction: value.substr(0, 1),\n        steps: step ? toInt(step) ? toInt(step) : step : 0\n      };\n    }\n  });\n  define(Run, 'length', {\n    /**\n     * Gets value of the running distance based\n     * on zero-indexing number of slides.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      var settings = Glide.settings;\n      var length = Components.Html.slides.length; // If the `bound` option is active, a maximum running distance should be\n      // reduced by `perView` and `focusAt` settings. Running distance\n      // should end before creating an empty space after instance.\n\n      if (this.isBound()) {\n        return length - 1 - (toInt(settings.perView) - 1) + toInt(settings.focusAt);\n      }\n\n      return length - 1;\n    }\n  });\n  define(Run, 'offset', {\n    /**\n     * Gets status of the offsetting flag.\n     *\n     * @return {Boolean}\n     */\n    get: function get() {\n      return this._o;\n    }\n  });\n  return Run;\n}\n\n/**\n * Returns a current time.\n *\n * @return {Number}\n */\nfunction now() {\n  return new Date().getTime();\n}\n\n/**\n * Returns a function, that, when invoked, will only be triggered\n * at most once during a given window of time.\n *\n * @param {Function} func\n * @param {Number} wait\n * @param {Object=} options\n * @return {Function}\n *\n * @see https://github.com/jashkenas/underscore\n */\n\nfunction throttle(func, wait, options) {\n  var timeout, context, args, result;\n  var previous = 0;\n  if (!options) options = {};\n\n  var later = function later() {\n    previous = options.leading === false ? 0 : now();\n    timeout = null;\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n\n  var throttled = function throttled() {\n    var at = now();\n    if (!previous && options.leading === false) previous = at;\n    var remaining = wait - (at - previous);\n    context = this;\n    args = arguments;\n\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n\n      previous = at;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n\n  throttled.cancel = function () {\n    clearTimeout(timeout);\n    previous = 0;\n    timeout = context = args = null;\n  };\n\n  return throttled;\n}\n\nvar MARGIN_TYPE = {\n  ltr: ['marginLeft', 'marginRight'],\n  rtl: ['marginRight', 'marginLeft']\n};\nfunction Gaps (Glide, Components, Events) {\n  var Gaps = {\n    /**\n     * Applies gaps between slides. First and last\n     * slides do not receive it's edge margins.\n     *\n     * @param {HTMLCollection} slides\n     * @return {Void}\n     */\n    apply: function apply(slides) {\n      for (var i = 0, len = slides.length; i < len; i++) {\n        var style = slides[i].style;\n        var direction = Components.Direction.value;\n\n        if (i !== 0) {\n          style[MARGIN_TYPE[direction][0]] = \"\".concat(this.value / 2, \"px\");\n        } else {\n          style[MARGIN_TYPE[direction][0]] = '';\n        }\n\n        if (i !== slides.length - 1) {\n          style[MARGIN_TYPE[direction][1]] = \"\".concat(this.value / 2, \"px\");\n        } else {\n          style[MARGIN_TYPE[direction][1]] = '';\n        }\n      }\n    },\n\n    /**\n     * Removes gaps from the slides.\n     *\n     * @param {HTMLCollection} slides\n     * @returns {Void}\n    */\n    remove: function remove(slides) {\n      for (var i = 0, len = slides.length; i < len; i++) {\n        var style = slides[i].style;\n        style.marginLeft = '';\n        style.marginRight = '';\n      }\n    }\n  };\n  define(Gaps, 'value', {\n    /**\n     * Gets value of the gap.\n     *\n     * @returns {Number}\n     */\n    get: function get() {\n      return toInt(Glide.settings.gap);\n    }\n  });\n  define(Gaps, 'grow', {\n    /**\n     * Gets additional dimensions value caused by gaps.\n     * Used to increase width of the slides wrapper.\n     *\n     * @returns {Number}\n     */\n    get: function get() {\n      return Gaps.value * Components.Sizes.length;\n    }\n  });\n  define(Gaps, 'reductor', {\n    /**\n     * Gets reduction value caused by gaps.\n     * Used to subtract width of the slides.\n     *\n     * @returns {Number}\n     */\n    get: function get() {\n      var perView = Glide.settings.perView;\n      return Gaps.value * (perView - 1) / perView;\n    }\n  });\n  /**\n   * Apply calculated gaps:\n   * - after building, so slides (including clones) will receive proper margins\n   * - on updating via API, to recalculate gaps with new options\n   */\n\n  Events.on(['build.after', 'update'], throttle(function () {\n    Gaps.apply(Components.Html.wrapper.children);\n  }, 30));\n  /**\n   * Remove gaps:\n   * - on destroying to bring markup to its inital state\n   */\n\n  Events.on('destroy', function () {\n    Gaps.remove(Components.Html.wrapper.children);\n  });\n  return Gaps;\n}\n\n/**\n * Finds siblings nodes of the passed node.\n *\n * @param  {Element} node\n * @return {Array}\n */\nfunction siblings(node) {\n  if (node && node.parentNode) {\n    var n = node.parentNode.firstChild;\n    var matched = [];\n\n    for (; n; n = n.nextSibling) {\n      if (n.nodeType === 1 && n !== node) {\n        matched.push(n);\n      }\n    }\n\n    return matched;\n  }\n\n  return [];\n}\n/**\n * Checks if passed node exist and is a valid element.\n *\n * @param  {Element} node\n * @return {Boolean}\n */\n\nfunction exist(node) {\n  if (node && node instanceof window.HTMLElement) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Coerces a NodeList to an Array.\n *\n * @param  {NodeList} nodeList\n * @return {Array}\n */\n\nfunction toArray(nodeList) {\n  return Array.prototype.slice.call(nodeList);\n}\n\nvar TRACK_SELECTOR = '[data-glide-el=\"track\"]';\nfunction Html (Glide, Components, Events) {\n  var Html = {\n    /**\n     * Setup slider HTML nodes.\n     *\n     * @param {Glide} glide\n     */\n    mount: function mount() {\n      this.root = Glide.selector;\n      this.track = this.root.querySelector(TRACK_SELECTOR);\n      this.collectSlides();\n    },\n\n    /**\n     * Collect slides\n     */\n    collectSlides: function collectSlides() {\n      this.slides = toArray(this.wrapper.children).filter(function (slide) {\n        return !slide.classList.contains(Glide.settings.classes.slide.clone);\n      });\n    }\n  };\n  define(Html, 'root', {\n    /**\n     * Gets node of the glide main element.\n     *\n     * @return {Object}\n     */\n    get: function get() {\n      return Html._r;\n    },\n\n    /**\n     * Sets node of the glide main element.\n     *\n     * @return {Object}\n     */\n    set: function set(r) {\n      if (isString(r)) {\n        r = document.querySelector(r);\n      }\n\n      if (exist(r)) {\n        Html._r = r;\n      } else {\n        warn('Root element must be a existing Html node');\n      }\n    }\n  });\n  define(Html, 'track', {\n    /**\n     * Gets node of the glide track with slides.\n     *\n     * @return {Object}\n     */\n    get: function get() {\n      return Html._t;\n    },\n\n    /**\n     * Sets node of the glide track with slides.\n     *\n     * @return {Object}\n     */\n    set: function set(t) {\n      if (exist(t)) {\n        Html._t = t;\n      } else {\n        warn(\"Could not find track element. Please use \".concat(TRACK_SELECTOR, \" attribute.\"));\n      }\n    }\n  });\n  define(Html, 'wrapper', {\n    /**\n     * Gets node of the slides wrapper.\n     *\n     * @return {Object}\n     */\n    get: function get() {\n      return Html.track.children[0];\n    }\n  });\n  /**\n   * Add/remove/reorder dynamic slides\n   */\n\n  Events.on('update', function () {\n    Html.collectSlides();\n  });\n  return Html;\n}\n\nfunction Peek (Glide, Components, Events) {\n  var Peek = {\n    /**\n     * Setups how much to peek based on settings.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      this.value = Glide.settings.peek;\n    }\n  };\n  define(Peek, 'value', {\n    /**\n     * Gets value of the peek.\n     *\n     * @returns {Number|Object}\n     */\n    get: function get() {\n      return Peek._v;\n    },\n\n    /**\n     * Sets value of the peek.\n     *\n     * @param {Number|Object} value\n     * @return {Void}\n     */\n    set: function set(value) {\n      if (isObject(value)) {\n        value.before = toInt(value.before);\n        value.after = toInt(value.after);\n      } else {\n        value = toInt(value);\n      }\n\n      Peek._v = value;\n    }\n  });\n  define(Peek, 'reductor', {\n    /**\n     * Gets reduction value caused by peek.\n     *\n     * @returns {Number}\n     */\n    get: function get() {\n      var value = Peek.value;\n      var perView = Glide.settings.perView;\n\n      if (isObject(value)) {\n        return value.before / perView + value.after / perView;\n      }\n\n      return value * 2 / perView;\n    }\n  });\n  /**\n   * Recalculate peeking sizes on:\n   * - when resizing window to update to proper percents\n   */\n\n  Events.on(['resize', 'update'], function () {\n    Peek.mount();\n  });\n  return Peek;\n}\n\nfunction Move (Glide, Components, Events) {\n  var Move = {\n    /**\n     * Constructs move component.\n     *\n     * @returns {Void}\n     */\n    mount: function mount() {\n      this._o = 0;\n    },\n\n    /**\n     * Calculates a movement value based on passed offset and currently active index.\n     *\n     * @param  {Number} offset\n     * @return {Void}\n     */\n    make: function make() {\n      var _this = this;\n\n      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this.offset = offset;\n      Events.emit('move', {\n        movement: this.value\n      });\n      Components.Transition.after(function () {\n        Events.emit('move.after', {\n          movement: _this.value\n        });\n      });\n    }\n  };\n  define(Move, 'offset', {\n    /**\n     * Gets an offset value used to modify current translate.\n     *\n     * @return {Object}\n     */\n    get: function get() {\n      return Move._o;\n    },\n\n    /**\n     * Sets an offset value used to modify current translate.\n     *\n     * @return {Object}\n     */\n    set: function set(value) {\n      Move._o = !isUndefined(value) ? toInt(value) : 0;\n    }\n  });\n  define(Move, 'translate', {\n    /**\n     * Gets a raw movement value.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      return Components.Sizes.slideWidth * Glide.index;\n    }\n  });\n  define(Move, 'value', {\n    /**\n     * Gets an actual movement value corrected by offset.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      var offset = this.offset;\n      var translate = this.translate;\n\n      if (Components.Direction.is('rtl')) {\n        return translate + offset;\n      }\n\n      return translate - offset;\n    }\n  });\n  /**\n   * Make movement to proper slide on:\n   * - before build, so glide will start at `startAt` index\n   * - on each standard run to move to newly calculated index\n   */\n\n  Events.on(['build.before', 'run'], function () {\n    Move.make();\n  });\n  return Move;\n}\n\nfunction Sizes (Glide, Components, Events) {\n  var Sizes = {\n    /**\n     * Setups dimensions of slides.\n     *\n     * @return {Void}\n     */\n    setupSlides: function setupSlides() {\n      var width = \"\".concat(this.slideWidth, \"px\");\n      var slides = Components.Html.slides;\n\n      for (var i = 0; i < slides.length; i++) {\n        slides[i].style.width = width;\n      }\n    },\n\n    /**\n     * Setups dimensions of slides wrapper.\n     *\n     * @return {Void}\n     */\n    setupWrapper: function setupWrapper() {\n      Components.Html.wrapper.style.width = \"\".concat(this.wrapperSize, \"px\");\n    },\n\n    /**\n     * Removes applied styles from HTML elements.\n     *\n     * @returns {Void}\n     */\n    remove: function remove() {\n      var slides = Components.Html.slides;\n\n      for (var i = 0; i < slides.length; i++) {\n        slides[i].style.width = '';\n      }\n\n      Components.Html.wrapper.style.width = '';\n    }\n  };\n  define(Sizes, 'length', {\n    /**\n     * Gets count number of the slides.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      return Components.Html.slides.length;\n    }\n  });\n  define(Sizes, 'width', {\n    /**\n     * Gets width value of the slider (visible area).\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      return Components.Html.track.offsetWidth;\n    }\n  });\n  define(Sizes, 'wrapperSize', {\n    /**\n     * Gets size of the slides wrapper.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      return Sizes.slideWidth * Sizes.length + Components.Gaps.grow + Components.Clones.grow;\n    }\n  });\n  define(Sizes, 'slideWidth', {\n    /**\n     * Gets width value of a single slide.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      return Sizes.width / Glide.settings.perView - Components.Peek.reductor - Components.Gaps.reductor;\n    }\n  });\n  /**\n   * Apply calculated glide's dimensions:\n   * - before building, so other dimensions (e.g. translate) will be calculated propertly\n   * - when resizing window to recalculate sildes dimensions\n   * - on updating via API, to calculate dimensions based on new options\n   */\n\n  Events.on(['build.before', 'resize', 'update'], function () {\n    Sizes.setupSlides();\n    Sizes.setupWrapper();\n  });\n  /**\n   * Remove calculated glide's dimensions:\n   * - on destoting to bring markup to its inital state\n   */\n\n  Events.on('destroy', function () {\n    Sizes.remove();\n  });\n  return Sizes;\n}\n\nfunction Build (Glide, Components, Events) {\n  var Build = {\n    /**\n     * Init glide building. Adds classes, sets\n     * dimensions and setups initial state.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      Events.emit('build.before');\n      this.typeClass();\n      this.activeClass();\n      Events.emit('build.after');\n    },\n\n    /**\n     * Adds `type` class to the glide element.\n     *\n     * @return {Void}\n     */\n    typeClass: function typeClass() {\n      Components.Html.root.classList.add(Glide.settings.classes.type[Glide.settings.type]);\n    },\n\n    /**\n     * Sets active class to current slide.\n     *\n     * @return {Void}\n     */\n    activeClass: function activeClass() {\n      var classes = Glide.settings.classes;\n      var slide = Components.Html.slides[Glide.index];\n\n      if (slide) {\n        slide.classList.add(classes.slide.active);\n        siblings(slide).forEach(function (sibling) {\n          sibling.classList.remove(classes.slide.active);\n        });\n      }\n    },\n\n    /**\n     * Removes HTML classes applied at building.\n     *\n     * @return {Void}\n     */\n    removeClasses: function removeClasses() {\n      var _Glide$settings$class = Glide.settings.classes,\n          type = _Glide$settings$class.type,\n          slide = _Glide$settings$class.slide;\n      Components.Html.root.classList.remove(type[Glide.settings.type]);\n      Components.Html.slides.forEach(function (sibling) {\n        sibling.classList.remove(slide.active);\n      });\n    }\n  };\n  /**\n   * Clear building classes:\n   * - on destroying to bring HTML to its initial state\n   * - on updating to remove classes before remounting component\n   */\n\n  Events.on(['destroy', 'update'], function () {\n    Build.removeClasses();\n  });\n  /**\n   * Remount component:\n   * - on resizing of the window to calculate new dimensions\n   * - on updating settings via API\n   */\n\n  Events.on(['resize', 'update'], function () {\n    Build.mount();\n  });\n  /**\n   * Swap active class of current slide:\n   * - after each move to the new index\n   */\n\n  Events.on('move.after', function () {\n    Build.activeClass();\n  });\n  return Build;\n}\n\nfunction Clones (Glide, Components, Events) {\n  var Clones = {\n    /**\n     * Create pattern map and collect slides to be cloned.\n     */\n    mount: function mount() {\n      this.items = [];\n\n      if (Glide.isType('carousel')) {\n        this.items = this.collect();\n      }\n    },\n\n    /**\n     * Collect clones with pattern.\n     *\n     * @return {[]}\n     */\n    collect: function collect() {\n      var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var slides = Components.Html.slides;\n      var _Glide$settings = Glide.settings,\n          perView = _Glide$settings.perView,\n          classes = _Glide$settings.classes,\n          cloningRatio = _Glide$settings.cloningRatio;\n\n      if (slides.length !== 0) {\n        var peekIncrementer = +!!Glide.settings.peek;\n        var cloneCount = perView + peekIncrementer + Math.round(perView / 2);\n        var append = slides.slice(0, cloneCount).reverse();\n        var prepend = slides.slice(cloneCount * -1);\n\n        for (var r = 0; r < Math.max(cloningRatio, Math.floor(perView / slides.length)); r++) {\n          for (var i = 0; i < append.length; i++) {\n            var clone = append[i].cloneNode(true);\n            clone.classList.add(classes.slide.clone);\n            items.push(clone);\n          }\n\n          for (var _i = 0; _i < prepend.length; _i++) {\n            var _clone = prepend[_i].cloneNode(true);\n\n            _clone.classList.add(classes.slide.clone);\n\n            items.unshift(_clone);\n          }\n        }\n      }\n\n      return items;\n    },\n\n    /**\n     * Append cloned slides with generated pattern.\n     *\n     * @return {Void}\n     */\n    append: function append() {\n      var items = this.items;\n      var _Components$Html = Components.Html,\n          wrapper = _Components$Html.wrapper,\n          slides = _Components$Html.slides;\n      var half = Math.floor(items.length / 2);\n      var prepend = items.slice(0, half).reverse();\n      var append = items.slice(half * -1).reverse();\n      var width = \"\".concat(Components.Sizes.slideWidth, \"px\");\n\n      for (var i = 0; i < append.length; i++) {\n        wrapper.appendChild(append[i]);\n      }\n\n      for (var _i2 = 0; _i2 < prepend.length; _i2++) {\n        wrapper.insertBefore(prepend[_i2], slides[0]);\n      }\n\n      for (var _i3 = 0; _i3 < items.length; _i3++) {\n        items[_i3].style.width = width;\n      }\n    },\n\n    /**\n     * Remove all cloned slides.\n     *\n     * @return {Void}\n     */\n    remove: function remove() {\n      var items = this.items;\n\n      for (var i = 0; i < items.length; i++) {\n        Components.Html.wrapper.removeChild(items[i]);\n      }\n    }\n  };\n  define(Clones, 'grow', {\n    /**\n     * Gets additional dimensions value caused by clones.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      return (Components.Sizes.slideWidth + Components.Gaps.value) * Clones.items.length;\n    }\n  });\n  /**\n   * Append additional slide's clones:\n   * - while glide's type is `carousel`\n   */\n\n  Events.on('update', function () {\n    Clones.remove();\n    Clones.mount();\n    Clones.append();\n  });\n  /**\n   * Append additional slide's clones:\n   * - while glide's type is `carousel`\n   */\n\n  Events.on('build.before', function () {\n    if (Glide.isType('carousel')) {\n      Clones.append();\n    }\n  });\n  /**\n   * Remove clones HTMLElements:\n   * - on destroying, to bring HTML to its initial state\n   */\n\n  Events.on('destroy', function () {\n    Clones.remove();\n  });\n  return Clones;\n}\n\nvar EventsBinder = /*#__PURE__*/function () {\n  /**\n   * Construct a EventsBinder instance.\n   */\n  function EventsBinder() {\n    var listeners = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, EventsBinder);\n\n    this.listeners = listeners;\n  }\n  /**\n   * Adds events listeners to arrows HTML elements.\n   *\n   * @param  {String|Array} events\n   * @param  {Element|Window|Document} el\n   * @param  {Function} closure\n   * @param  {Boolean|Object} capture\n   * @return {Void}\n   */\n\n\n  _createClass(EventsBinder, [{\n    key: \"on\",\n    value: function on(events, el, closure) {\n      var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      if (isString(events)) {\n        events = [events];\n      }\n\n      for (var i = 0; i < events.length; i++) {\n        this.listeners[events[i]] = closure;\n        el.addEventListener(events[i], this.listeners[events[i]], capture);\n      }\n    }\n    /**\n     * Removes event listeners from arrows HTML elements.\n     *\n     * @param  {String|Array} events\n     * @param  {Element|Window|Document} el\n     * @param  {Boolean|Object} capture\n     * @return {Void}\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(events, el) {\n      var capture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (isString(events)) {\n        events = [events];\n      }\n\n      for (var i = 0; i < events.length; i++) {\n        el.removeEventListener(events[i], this.listeners[events[i]], capture);\n      }\n    }\n    /**\n     * Destroy collected listeners.\n     *\n     * @returns {Void}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      delete this.listeners;\n    }\n  }]);\n\n  return EventsBinder;\n}();\n\nfunction Resize (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  var Resize = {\n    /**\n     * Initializes window bindings.\n     */\n    mount: function mount() {\n      this.bind();\n    },\n\n    /**\n     * Binds `rezsize` listener to the window.\n     * It's a costly event, so we are debouncing it.\n     *\n     * @return {Void}\n     */\n    bind: function bind() {\n      Binder.on('resize', window, throttle(function () {\n        Events.emit('resize');\n      }, Glide.settings.throttle));\n    },\n\n    /**\n     * Unbinds listeners from the window.\n     *\n     * @return {Void}\n     */\n    unbind: function unbind() {\n      Binder.off('resize', window);\n    }\n  };\n  /**\n   * Remove bindings from window:\n   * - on destroying, to remove added EventListener\n   */\n\n  Events.on('destroy', function () {\n    Resize.unbind();\n    Binder.destroy();\n  });\n  return Resize;\n}\n\nvar VALID_DIRECTIONS = ['ltr', 'rtl'];\nvar FLIPED_MOVEMENTS = {\n  '>': '<',\n  '<': '>',\n  '=': '='\n};\nfunction Direction (Glide, Components, Events) {\n  var Direction = {\n    /**\n     * Setups gap value based on settings.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      this.value = Glide.settings.direction;\n    },\n\n    /**\n     * Resolves pattern based on direction value\n     *\n     * @param {String} pattern\n     * @returns {String}\n     */\n    resolve: function resolve(pattern) {\n      var token = pattern.slice(0, 1);\n\n      if (this.is('rtl')) {\n        return pattern.split(token).join(FLIPED_MOVEMENTS[token]);\n      }\n\n      return pattern;\n    },\n\n    /**\n     * Checks value of direction mode.\n     *\n     * @param {String} direction\n     * @returns {Boolean}\n     */\n    is: function is(direction) {\n      return this.value === direction;\n    },\n\n    /**\n     * Applies direction class to the root HTML element.\n     *\n     * @return {Void}\n     */\n    addClass: function addClass() {\n      Components.Html.root.classList.add(Glide.settings.classes.direction[this.value]);\n    },\n\n    /**\n     * Removes direction class from the root HTML element.\n     *\n     * @return {Void}\n     */\n    removeClass: function removeClass() {\n      Components.Html.root.classList.remove(Glide.settings.classes.direction[this.value]);\n    }\n  };\n  define(Direction, 'value', {\n    /**\n     * Gets value of the direction.\n     *\n     * @returns {Number}\n     */\n    get: function get() {\n      return Direction._v;\n    },\n\n    /**\n     * Sets value of the direction.\n     *\n     * @param {String} value\n     * @return {Void}\n     */\n    set: function set(value) {\n      if (VALID_DIRECTIONS.indexOf(value) > -1) {\n        Direction._v = value;\n      } else {\n        warn('Direction value must be `ltr` or `rtl`');\n      }\n    }\n  });\n  /**\n   * Clear direction class:\n   * - on destroy to bring HTML to its initial state\n   * - on update to remove class before reappling bellow\n   */\n\n  Events.on(['destroy', 'update'], function () {\n    Direction.removeClass();\n  });\n  /**\n   * Remount component:\n   * - on update to reflect changes in direction value\n   */\n\n  Events.on('update', function () {\n    Direction.mount();\n  });\n  /**\n   * Apply direction class:\n   * - before building to apply class for the first time\n   * - on updating to reapply direction class that may changed\n   */\n\n  Events.on(['build.before', 'update'], function () {\n    Direction.addClass();\n  });\n  return Direction;\n}\n\n/**\n * Reflects value of glide movement.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */\nfunction Rtl (Glide, Components) {\n  return {\n    /**\n     * Negates the passed translate if glide is in RTL option.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */\n    modify: function modify(translate) {\n      if (Components.Direction.is('rtl')) {\n        return -translate;\n      }\n\n      return translate;\n    }\n  };\n}\n\n/**\n * Updates glide movement with a `gap` settings.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */\nfunction Gap (Glide, Components) {\n  return {\n    /**\n     * Modifies passed translate value with number in the `gap` settings.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */\n    modify: function modify(translate) {\n      var multiplier = Math.floor(translate / Components.Sizes.slideWidth);\n      return translate + Components.Gaps.value * multiplier;\n    }\n  };\n}\n\n/**\n * Updates glide movement with width of additional clones width.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */\nfunction Grow (Glide, Components) {\n  return {\n    /**\n     * Adds to the passed translate width of the half of clones.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */\n    modify: function modify(translate) {\n      return translate + Components.Clones.grow / 2;\n    }\n  };\n}\n\n/**\n * Updates glide movement with a `peek` settings.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */\n\nfunction Peeking (Glide, Components) {\n  return {\n    /**\n     * Modifies passed translate value with a `peek` setting.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */\n    modify: function modify(translate) {\n      if (Glide.settings.focusAt >= 0) {\n        var peek = Components.Peek.value;\n\n        if (isObject(peek)) {\n          return translate - peek.before;\n        }\n\n        return translate - peek;\n      }\n\n      return translate;\n    }\n  };\n}\n\n/**\n * Updates glide movement with a `focusAt` settings.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */\nfunction Focusing (Glide, Components) {\n  return {\n    /**\n     * Modifies passed translate value with index in the `focusAt` setting.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */\n    modify: function modify(translate) {\n      var gap = Components.Gaps.value;\n      var width = Components.Sizes.width;\n      var focusAt = Glide.settings.focusAt;\n      var slideWidth = Components.Sizes.slideWidth;\n\n      if (focusAt === 'center') {\n        return translate - (width / 2 - slideWidth / 2);\n      }\n\n      return translate - slideWidth * focusAt - gap * focusAt;\n    }\n  };\n}\n\n/**\n * Applies diffrent transformers on translate value.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */\n\nfunction mutator (Glide, Components, Events) {\n  /**\n   * Merge instance transformers with collection of default transformers.\n   * It's important that the Rtl component be last on the list,\n   * so it reflects all previous transformations.\n   *\n   * @type {Array}\n   */\n  var TRANSFORMERS = [Gap, Grow, Peeking, Focusing].concat(Glide._t, [Rtl]);\n  return {\n    /**\n     * Piplines translate value with registered transformers.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */\n    mutate: function mutate(translate) {\n      for (var i = 0; i < TRANSFORMERS.length; i++) {\n        var transformer = TRANSFORMERS[i];\n\n        if (isFunction(transformer) && isFunction(transformer().modify)) {\n          translate = transformer(Glide, Components, Events).modify(translate);\n        } else {\n          warn('Transformer should be a function that returns an object with `modify()` method');\n        }\n      }\n\n      return translate;\n    }\n  };\n}\n\nfunction Translate (Glide, Components, Events) {\n  var Translate = {\n    /**\n     * Sets value of translate on HTML element.\n     *\n     * @param {Number} value\n     * @return {Void}\n     */\n    set: function set(value) {\n      var transform = mutator(Glide, Components).mutate(value);\n      var translate3d = \"translate3d(\".concat(-1 * transform, \"px, 0px, 0px)\");\n      Components.Html.wrapper.style.mozTransform = translate3d; // needed for supported Firefox 10-15\n\n      Components.Html.wrapper.style.webkitTransform = translate3d; // needed for supported Chrome 10-35, Safari 5.1-8, and Opera 15-22\n\n      Components.Html.wrapper.style.transform = translate3d;\n    },\n\n    /**\n     * Removes value of translate from HTML element.\n     *\n     * @return {Void}\n     */\n    remove: function remove() {\n      Components.Html.wrapper.style.transform = '';\n    },\n\n    /**\n     * @return {number}\n     */\n    getStartIndex: function getStartIndex() {\n      var length = Components.Sizes.length;\n      var index = Glide.index;\n      var perView = Glide.settings.perView;\n\n      if (Components.Run.isOffset('>') || Components.Run.isOffset('|>')) {\n        return length + (index - perView);\n      } // \"modulo length\" converts an index that equals length to zero\n\n\n      return (index + perView) % length;\n    },\n\n    /**\n     * @return {number}\n     */\n    getTravelDistance: function getTravelDistance() {\n      var travelDistance = Components.Sizes.slideWidth * Glide.settings.perView;\n\n      if (Components.Run.isOffset('>') || Components.Run.isOffset('|>')) {\n        // reverse travel distance so that we don't have to change subtract operations\n        return travelDistance * -1;\n      }\n\n      return travelDistance;\n    }\n  };\n  /**\n   * Set new translate value:\n   * - on move to reflect index change\n   * - on updating via API to reflect possible changes in options\n   */\n\n  Events.on('move', function (context) {\n    if (!Glide.isType('carousel') || !Components.Run.isOffset()) {\n      return Translate.set(context.movement);\n    }\n\n    Components.Transition.after(function () {\n      Events.emit('translate.jump');\n      Translate.set(Components.Sizes.slideWidth * Glide.index);\n    });\n    var startWidth = Components.Sizes.slideWidth * Components.Translate.getStartIndex();\n    return Translate.set(startWidth - Components.Translate.getTravelDistance());\n  });\n  /**\n   * Remove translate:\n   * - on destroying to bring markup to its inital state\n   */\n\n  Events.on('destroy', function () {\n    Translate.remove();\n  });\n  return Translate;\n}\n\nfunction Transition (Glide, Components, Events) {\n  /**\n   * Holds inactivity status of transition.\n   * When true transition is not applied.\n   *\n   * @type {Boolean}\n   */\n  var disabled = false;\n  var Transition = {\n    /**\n     * Composes string of the CSS transition.\n     *\n     * @param {String} property\n     * @return {String}\n     */\n    compose: function compose(property) {\n      var settings = Glide.settings;\n\n      if (!disabled) {\n        return \"\".concat(property, \" \").concat(this.duration, \"ms \").concat(settings.animationTimingFunc);\n      }\n\n      return \"\".concat(property, \" 0ms \").concat(settings.animationTimingFunc);\n    },\n\n    /**\n     * Sets value of transition on HTML element.\n     *\n     * @param {String=} property\n     * @return {Void}\n     */\n    set: function set() {\n      var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';\n      Components.Html.wrapper.style.transition = this.compose(property);\n    },\n\n    /**\n     * Removes value of transition from HTML element.\n     *\n     * @return {Void}\n     */\n    remove: function remove() {\n      Components.Html.wrapper.style.transition = '';\n    },\n\n    /**\n     * Runs callback after animation.\n     *\n     * @param  {Function} callback\n     * @return {Void}\n     */\n    after: function after(callback) {\n      setTimeout(function () {\n        callback();\n      }, this.duration);\n    },\n\n    /**\n     * Enable transition.\n     *\n     * @return {Void}\n     */\n    enable: function enable() {\n      disabled = false;\n      this.set();\n    },\n\n    /**\n     * Disable transition.\n     *\n     * @return {Void}\n     */\n    disable: function disable() {\n      disabled = true;\n      this.set();\n    }\n  };\n  define(Transition, 'duration', {\n    /**\n     * Gets duration of the transition based\n     * on currently running animation type.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      var settings = Glide.settings;\n\n      if (Glide.isType('slider') && Components.Run.offset) {\n        return settings.rewindDuration;\n      }\n\n      return settings.animationDuration;\n    }\n  });\n  /**\n   * Set transition `style` value:\n   * - on each moving, because it may be cleared by offset move\n   */\n\n  Events.on('move', function () {\n    Transition.set();\n  });\n  /**\n   * Disable transition:\n   * - before initial build to avoid transitioning from `0` to `startAt` index\n   * - while resizing window and recalculating dimensions\n   * - on jumping from offset transition at start and end edges in `carousel` type\n   */\n\n  Events.on(['build.before', 'resize', 'translate.jump'], function () {\n    Transition.disable();\n  });\n  /**\n   * Enable transition:\n   * - on each running, because it may be disabled by offset move\n   */\n\n  Events.on('run', function () {\n    Transition.enable();\n  });\n  /**\n   * Remove transition:\n   * - on destroying to bring markup to its inital state\n   */\n\n  Events.on('destroy', function () {\n    Transition.remove();\n  });\n  return Transition;\n}\n\n/**\n * Test via a getter in the options object to see\n * if the passive property is accessed.\n *\n * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n */\nvar supportsPassive = false;\n\ntry {\n  var opts = Object.defineProperty({}, 'passive', {\n    get: function get() {\n      supportsPassive = true;\n    }\n  });\n  window.addEventListener('testPassive', null, opts);\n  window.removeEventListener('testPassive', null, opts);\n} catch (e) {}\n\nvar supportsPassive$1 = supportsPassive;\n\nvar START_EVENTS = ['touchstart', 'mousedown'];\nvar MOVE_EVENTS = ['touchmove', 'mousemove'];\nvar END_EVENTS = ['touchend', 'touchcancel', 'mouseup', 'mouseleave'];\nvar MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'mouseleave'];\nfunction Swipe (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  var swipeSin = 0;\n  var swipeStartX = 0;\n  var swipeStartY = 0;\n  var disabled = false;\n  var capture = supportsPassive$1 ? {\n    passive: true\n  } : false;\n  var Swipe = {\n    /**\n     * Initializes swipe bindings.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      this.bindSwipeStart();\n    },\n\n    /**\n     * Handler for `swipestart` event. Calculates entry points of the user's tap.\n     *\n     * @param {Object} event\n     * @return {Void}\n     */\n    start: function start(event) {\n      if (!disabled && !Glide.disabled) {\n        this.disable();\n        var swipe = this.touches(event);\n        swipeSin = null;\n        swipeStartX = toInt(swipe.pageX);\n        swipeStartY = toInt(swipe.pageY);\n        this.bindSwipeMove();\n        this.bindSwipeEnd();\n        Events.emit('swipe.start');\n      }\n    },\n\n    /**\n     * Handler for `swipemove` event. Calculates user's tap angle and distance.\n     *\n     * @param {Object} event\n     */\n    move: function move(event) {\n      if (!Glide.disabled) {\n        var _Glide$settings = Glide.settings,\n            touchAngle = _Glide$settings.touchAngle,\n            touchRatio = _Glide$settings.touchRatio,\n            classes = _Glide$settings.classes;\n        var swipe = this.touches(event);\n        var subExSx = toInt(swipe.pageX) - swipeStartX;\n        var subEySy = toInt(swipe.pageY) - swipeStartY;\n        var powEX = Math.abs(subExSx << 2);\n        var powEY = Math.abs(subEySy << 2);\n        var swipeHypotenuse = Math.sqrt(powEX + powEY);\n        var swipeCathetus = Math.sqrt(powEY);\n        swipeSin = Math.asin(swipeCathetus / swipeHypotenuse);\n\n        if (swipeSin * 180 / Math.PI < touchAngle) {\n          event.stopPropagation();\n          Components.Move.make(subExSx * toFloat(touchRatio));\n          Components.Html.root.classList.add(classes.dragging);\n          Events.emit('swipe.move');\n        } else {\n          return false;\n        }\n      }\n    },\n\n    /**\n     * Handler for `swipeend` event. Finitializes user's tap and decides about glide move.\n     *\n     * @param {Object} event\n     * @return {Void}\n     */\n    end: function end(event) {\n      if (!Glide.disabled) {\n        var _Glide$settings2 = Glide.settings,\n            perSwipe = _Glide$settings2.perSwipe,\n            touchAngle = _Glide$settings2.touchAngle,\n            classes = _Glide$settings2.classes;\n        var swipe = this.touches(event);\n        var threshold = this.threshold(event);\n        var swipeDistance = swipe.pageX - swipeStartX;\n        var swipeDeg = swipeSin * 180 / Math.PI;\n        this.enable();\n\n        if (swipeDistance > threshold && swipeDeg < touchAngle) {\n          Components.Run.make(Components.Direction.resolve(\"\".concat(perSwipe, \"<\")));\n        } else if (swipeDistance < -threshold && swipeDeg < touchAngle) {\n          Components.Run.make(Components.Direction.resolve(\"\".concat(perSwipe, \">\")));\n        } else {\n          // While swipe don't reach distance apply previous transform.\n          Components.Move.make();\n        }\n\n        Components.Html.root.classList.remove(classes.dragging);\n        this.unbindSwipeMove();\n        this.unbindSwipeEnd();\n        Events.emit('swipe.end');\n      }\n    },\n\n    /**\n     * Binds swipe's starting event.\n     *\n     * @return {Void}\n     */\n    bindSwipeStart: function bindSwipeStart() {\n      var _this = this;\n\n      var _Glide$settings3 = Glide.settings,\n          swipeThreshold = _Glide$settings3.swipeThreshold,\n          dragThreshold = _Glide$settings3.dragThreshold;\n\n      if (swipeThreshold) {\n        Binder.on(START_EVENTS[0], Components.Html.wrapper, function (event) {\n          _this.start(event);\n        }, capture);\n      }\n\n      if (dragThreshold) {\n        Binder.on(START_EVENTS[1], Components.Html.wrapper, function (event) {\n          _this.start(event);\n        }, capture);\n      }\n    },\n\n    /**\n     * Unbinds swipe's starting event.\n     *\n     * @return {Void}\n     */\n    unbindSwipeStart: function unbindSwipeStart() {\n      Binder.off(START_EVENTS[0], Components.Html.wrapper, capture);\n      Binder.off(START_EVENTS[1], Components.Html.wrapper, capture);\n    },\n\n    /**\n     * Binds swipe's moving event.\n     *\n     * @return {Void}\n     */\n    bindSwipeMove: function bindSwipeMove() {\n      var _this2 = this;\n\n      Binder.on(MOVE_EVENTS, Components.Html.wrapper, throttle(function (event) {\n        _this2.move(event);\n      }, Glide.settings.throttle), capture);\n    },\n\n    /**\n     * Unbinds swipe's moving event.\n     *\n     * @return {Void}\n     */\n    unbindSwipeMove: function unbindSwipeMove() {\n      Binder.off(MOVE_EVENTS, Components.Html.wrapper, capture);\n    },\n\n    /**\n     * Binds swipe's ending event.\n     *\n     * @return {Void}\n     */\n    bindSwipeEnd: function bindSwipeEnd() {\n      var _this3 = this;\n\n      Binder.on(END_EVENTS, Components.Html.wrapper, function (event) {\n        _this3.end(event);\n      });\n    },\n\n    /**\n     * Unbinds swipe's ending event.\n     *\n     * @return {Void}\n     */\n    unbindSwipeEnd: function unbindSwipeEnd() {\n      Binder.off(END_EVENTS, Components.Html.wrapper);\n    },\n\n    /**\n     * Normalizes event touches points accorting to different types.\n     *\n     * @param {Object} event\n     */\n    touches: function touches(event) {\n      if (MOUSE_EVENTS.indexOf(event.type) > -1) {\n        return event;\n      }\n\n      return event.touches[0] || event.changedTouches[0];\n    },\n\n    /**\n     * Gets value of minimum swipe distance settings based on event type.\n     *\n     * @return {Number}\n     */\n    threshold: function threshold(event) {\n      var settings = Glide.settings;\n\n      if (MOUSE_EVENTS.indexOf(event.type) > -1) {\n        return settings.dragThreshold;\n      }\n\n      return settings.swipeThreshold;\n    },\n\n    /**\n     * Enables swipe event.\n     *\n     * @return {self}\n     */\n    enable: function enable() {\n      disabled = false;\n      Components.Transition.enable();\n      return this;\n    },\n\n    /**\n     * Disables swipe event.\n     *\n     * @return {self}\n     */\n    disable: function disable() {\n      disabled = true;\n      Components.Transition.disable();\n      return this;\n    }\n  };\n  /**\n   * Add component class:\n   * - after initial building\n   */\n\n  Events.on('build.after', function () {\n    Components.Html.root.classList.add(Glide.settings.classes.swipeable);\n  });\n  /**\n   * Remove swiping bindings:\n   * - on destroying, to remove added EventListeners\n   */\n\n  Events.on('destroy', function () {\n    Swipe.unbindSwipeStart();\n    Swipe.unbindSwipeMove();\n    Swipe.unbindSwipeEnd();\n    Binder.destroy();\n  });\n  return Swipe;\n}\n\nfunction Images (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  var Images = {\n    /**\n     * Binds listener to glide wrapper.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      this.bind();\n    },\n\n    /**\n     * Binds `dragstart` event on wrapper to prevent dragging images.\n     *\n     * @return {Void}\n     */\n    bind: function bind() {\n      Binder.on('dragstart', Components.Html.wrapper, this.dragstart);\n    },\n\n    /**\n     * Unbinds `dragstart` event on wrapper.\n     *\n     * @return {Void}\n     */\n    unbind: function unbind() {\n      Binder.off('dragstart', Components.Html.wrapper);\n    },\n\n    /**\n     * Event handler. Prevents dragging.\n     *\n     * @return {Void}\n     */\n    dragstart: function dragstart(event) {\n      event.preventDefault();\n    }\n  };\n  /**\n   * Remove bindings from images:\n   * - on destroying, to remove added EventListeners\n   */\n\n  Events.on('destroy', function () {\n    Images.unbind();\n    Binder.destroy();\n  });\n  return Images;\n}\n\nfunction Anchors (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  /**\n   * Holds detaching status of anchors.\n   * Prevents detaching of already detached anchors.\n   *\n   * @private\n   * @type {Boolean}\n   */\n\n  var detached = false;\n  /**\n   * Holds preventing status of anchors.\n   * If `true` redirection after click will be disabled.\n   *\n   * @private\n   * @type {Boolean}\n   */\n\n  var prevented = false;\n  var Anchors = {\n    /**\n     * Setups a initial state of anchors component.\n     *\n     * @returns {Void}\n     */\n    mount: function mount() {\n      /**\n       * Holds collection of anchors elements.\n       *\n       * @private\n       * @type {HTMLCollection}\n       */\n      this._a = Components.Html.wrapper.querySelectorAll('a');\n      this.bind();\n    },\n\n    /**\n     * Binds events to anchors inside a track.\n     *\n     * @return {Void}\n     */\n    bind: function bind() {\n      Binder.on('click', Components.Html.wrapper, this.click);\n    },\n\n    /**\n     * Unbinds events attached to anchors inside a track.\n     *\n     * @return {Void}\n     */\n    unbind: function unbind() {\n      Binder.off('click', Components.Html.wrapper);\n    },\n\n    /**\n     * Handler for click event. Prevents clicks when glide is in `prevent` status.\n     *\n     * @param  {Object} event\n     * @return {Void}\n     */\n    click: function click(event) {\n      if (prevented) {\n        event.stopPropagation();\n        event.preventDefault();\n      }\n    },\n\n    /**\n     * Detaches anchors click event inside glide.\n     *\n     * @return {self}\n     */\n    detach: function detach() {\n      prevented = true;\n\n      if (!detached) {\n        for (var i = 0; i < this.items.length; i++) {\n          this.items[i].draggable = false;\n        }\n\n        detached = true;\n      }\n\n      return this;\n    },\n\n    /**\n     * Attaches anchors click events inside glide.\n     *\n     * @return {self}\n     */\n    attach: function attach() {\n      prevented = false;\n\n      if (detached) {\n        for (var i = 0; i < this.items.length; i++) {\n          this.items[i].draggable = true;\n        }\n\n        detached = false;\n      }\n\n      return this;\n    }\n  };\n  define(Anchors, 'items', {\n    /**\n     * Gets collection of the arrows HTML elements.\n     *\n     * @return {HTMLElement[]}\n     */\n    get: function get() {\n      return Anchors._a;\n    }\n  });\n  /**\n   * Detach anchors inside slides:\n   * - on swiping, so they won't redirect to its `href` attributes\n   */\n\n  Events.on('swipe.move', function () {\n    Anchors.detach();\n  });\n  /**\n   * Attach anchors inside slides:\n   * - after swiping and transitions ends, so they can redirect after click again\n   */\n\n  Events.on('swipe.end', function () {\n    Components.Transition.after(function () {\n      Anchors.attach();\n    });\n  });\n  /**\n   * Unbind anchors inside slides:\n   * - on destroying, to bring anchors to its initial state\n   */\n\n  Events.on('destroy', function () {\n    Anchors.attach();\n    Anchors.unbind();\n    Binder.destroy();\n  });\n  return Anchors;\n}\n\nvar NAV_SELECTOR = '[data-glide-el=\"controls[nav]\"]';\nvar CONTROLS_SELECTOR = '[data-glide-el^=\"controls\"]';\nvar PREVIOUS_CONTROLS_SELECTOR = \"\".concat(CONTROLS_SELECTOR, \" [data-glide-dir*=\\\"<\\\"]\");\nvar NEXT_CONTROLS_SELECTOR = \"\".concat(CONTROLS_SELECTOR, \" [data-glide-dir*=\\\">\\\"]\");\nfunction Controls (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  var capture = supportsPassive$1 ? {\n    passive: true\n  } : false;\n  var Controls = {\n    /**\n     * Inits arrows. Binds events listeners\n     * to the arrows HTML elements.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      /**\n       * Collection of navigation HTML elements.\n       *\n       * @private\n       * @type {HTMLCollection}\n       */\n      this._n = Components.Html.root.querySelectorAll(NAV_SELECTOR);\n      /**\n       * Collection of controls HTML elements.\n       *\n       * @private\n       * @type {HTMLCollection}\n       */\n\n      this._c = Components.Html.root.querySelectorAll(CONTROLS_SELECTOR);\n      /**\n       * Collection of arrow control HTML elements.\n       *\n       * @private\n       * @type {Object}\n       */\n\n      this._arrowControls = {\n        previous: Components.Html.root.querySelectorAll(PREVIOUS_CONTROLS_SELECTOR),\n        next: Components.Html.root.querySelectorAll(NEXT_CONTROLS_SELECTOR)\n      };\n      this.addBindings();\n    },\n\n    /**\n     * Sets active class to current slide.\n     *\n     * @return {Void}\n     */\n    setActive: function setActive() {\n      for (var i = 0; i < this._n.length; i++) {\n        this.addClass(this._n[i].children);\n      }\n    },\n\n    /**\n     * Removes active class to current slide.\n     *\n     * @return {Void}\n     */\n    removeActive: function removeActive() {\n      for (var i = 0; i < this._n.length; i++) {\n        this.removeClass(this._n[i].children);\n      }\n    },\n\n    /**\n     * Toggles active class on items inside navigation.\n     *\n     * @param  {HTMLElement} controls\n     * @return {Void}\n     */\n    addClass: function addClass(controls) {\n      var settings = Glide.settings;\n      var item = controls[Glide.index];\n\n      if (!item) {\n        return;\n      }\n\n      if (item) {\n        item.classList.add(settings.classes.nav.active);\n        siblings(item).forEach(function (sibling) {\n          sibling.classList.remove(settings.classes.nav.active);\n        });\n      }\n    },\n\n    /**\n     * Removes active class from active control.\n     *\n     * @param  {HTMLElement} controls\n     * @return {Void}\n     */\n    removeClass: function removeClass(controls) {\n      var item = controls[Glide.index];\n\n      if (item) {\n        item.classList.remove(Glide.settings.classes.nav.active);\n      }\n    },\n\n    /**\n     * Calculates, removes or adds `Glide.settings.classes.disabledArrow` class on the control arrows\n     */\n    setArrowState: function setArrowState() {\n      if (Glide.settings.rewind) {\n        return;\n      }\n\n      var next = Controls._arrowControls.next;\n      var previous = Controls._arrowControls.previous;\n      this.resetArrowState(next, previous);\n\n      if (Glide.index === 0) {\n        this.disableArrow(previous);\n      }\n\n      if (Glide.index === Components.Run.length) {\n        this.disableArrow(next);\n      }\n    },\n\n    /**\n     * Removes `Glide.settings.classes.disabledArrow` from given NodeList elements\n     *\n     * @param {NodeList[]} lists\n     */\n    resetArrowState: function resetArrowState() {\n      var settings = Glide.settings;\n\n      for (var _len = arguments.length, lists = new Array(_len), _key = 0; _key < _len; _key++) {\n        lists[_key] = arguments[_key];\n      }\n\n      lists.forEach(function (list) {\n        toArray(list).forEach(function (element) {\n          element.classList.remove(settings.classes.arrow.disabled);\n        });\n      });\n    },\n\n    /**\n     * Adds `Glide.settings.classes.disabledArrow` to given NodeList elements\n     *\n     * @param {NodeList[]} lists\n     */\n    disableArrow: function disableArrow() {\n      var settings = Glide.settings;\n\n      for (var _len2 = arguments.length, lists = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        lists[_key2] = arguments[_key2];\n      }\n\n      lists.forEach(function (list) {\n        toArray(list).forEach(function (element) {\n          element.classList.add(settings.classes.arrow.disabled);\n        });\n      });\n    },\n\n    /**\n     * Adds handles to the each group of controls.\n     *\n     * @return {Void}\n     */\n    addBindings: function addBindings() {\n      for (var i = 0; i < this._c.length; i++) {\n        this.bind(this._c[i].children);\n      }\n    },\n\n    /**\n     * Removes handles from the each group of controls.\n     *\n     * @return {Void}\n     */\n    removeBindings: function removeBindings() {\n      for (var i = 0; i < this._c.length; i++) {\n        this.unbind(this._c[i].children);\n      }\n    },\n\n    /**\n     * Binds events to arrows HTML elements.\n     *\n     * @param {HTMLCollection} elements\n     * @return {Void}\n     */\n    bind: function bind(elements) {\n      for (var i = 0; i < elements.length; i++) {\n        Binder.on('click', elements[i], this.click);\n        Binder.on('touchstart', elements[i], this.click, capture);\n      }\n    },\n\n    /**\n     * Unbinds events binded to the arrows HTML elements.\n     *\n     * @param {HTMLCollection} elements\n     * @return {Void}\n     */\n    unbind: function unbind(elements) {\n      for (var i = 0; i < elements.length; i++) {\n        Binder.off(['click', 'touchstart'], elements[i]);\n      }\n    },\n\n    /**\n     * Handles `click` event on the arrows HTML elements.\n     * Moves slider in direction given via the\n     * `data-glide-dir` attribute.\n     *\n     * @param {Object} event\n     * @return {void}\n     */\n    click: function click(event) {\n      if (!supportsPassive$1 && event.type === 'touchstart') {\n        event.preventDefault();\n      }\n\n      var direction = event.currentTarget.getAttribute('data-glide-dir');\n      Components.Run.make(Components.Direction.resolve(direction));\n    }\n  };\n  define(Controls, 'items', {\n    /**\n     * Gets collection of the controls HTML elements.\n     *\n     * @return {HTMLElement[]}\n     */\n    get: function get() {\n      return Controls._c;\n    }\n  });\n  /**\n   * Swap active class of current navigation item:\n   * - after mounting to set it to initial index\n   * - after each move to the new index\n   */\n\n  Events.on(['mount.after', 'move.after'], function () {\n    Controls.setActive();\n  });\n  /**\n   * Add or remove disabled class of arrow elements\n   */\n\n  Events.on(['mount.after', 'run'], function () {\n    Controls.setArrowState();\n  });\n  /**\n   * Remove bindings and HTML Classes:\n   * - on destroying, to bring markup to its initial state\n   */\n\n  Events.on('destroy', function () {\n    Controls.removeBindings();\n    Controls.removeActive();\n    Binder.destroy();\n  });\n  return Controls;\n}\n\nfunction Keyboard (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  var Keyboard = {\n    /**\n     * Binds keyboard events on component mount.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      if (Glide.settings.keyboard) {\n        this.bind();\n      }\n    },\n\n    /**\n     * Adds keyboard press events.\n     *\n     * @return {Void}\n     */\n    bind: function bind() {\n      Binder.on('keyup', document, this.press);\n    },\n\n    /**\n     * Removes keyboard press events.\n     *\n     * @return {Void}\n     */\n    unbind: function unbind() {\n      Binder.off('keyup', document);\n    },\n\n    /**\n     * Handles keyboard's arrows press and moving glide foward and backward.\n     *\n     * @param  {Object} event\n     * @return {Void}\n     */\n    press: function press(event) {\n      var perSwipe = Glide.settings.perSwipe;\n\n      if (event.code === 'ArrowRight') {\n        Components.Run.make(Components.Direction.resolve(\"\".concat(perSwipe, \">\")));\n      }\n\n      if (event.code === 'ArrowLeft') {\n        Components.Run.make(Components.Direction.resolve(\"\".concat(perSwipe, \"<\")));\n      }\n    }\n  };\n  /**\n   * Remove bindings from keyboard:\n   * - on destroying to remove added events\n   * - on updating to remove events before remounting\n   */\n\n  Events.on(['destroy', 'update'], function () {\n    Keyboard.unbind();\n  });\n  /**\n   * Remount component\n   * - on updating to reflect potential changes in settings\n   */\n\n  Events.on('update', function () {\n    Keyboard.mount();\n  });\n  /**\n   * Destroy binder:\n   * - on destroying to remove listeners\n   */\n\n  Events.on('destroy', function () {\n    Binder.destroy();\n  });\n  return Keyboard;\n}\n\nfunction Autoplay (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  var Autoplay = {\n    /**\n     * Initializes autoplaying and events.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      this.enable();\n      this.start();\n\n      if (Glide.settings.hoverpause) {\n        this.bind();\n      }\n    },\n\n    /**\n     * Enables autoplaying\n     *\n     * @returns {Void}\n     */\n    enable: function enable() {\n      this._e = true;\n    },\n\n    /**\n     * Disables autoplaying.\n     *\n     * @returns {Void}\n     */\n    disable: function disable() {\n      this._e = false;\n    },\n\n    /**\n     * Starts autoplaying in configured interval.\n     *\n     * @param {Boolean|Number} force Run autoplaying with passed interval regardless of `autoplay` settings\n     * @return {Void}\n     */\n    start: function start() {\n      var _this = this;\n\n      if (!this._e) {\n        return;\n      }\n\n      this.enable();\n\n      if (Glide.settings.autoplay) {\n        if (isUndefined(this._i)) {\n          this._i = setInterval(function () {\n            _this.stop();\n\n            Components.Run.make('>');\n\n            _this.start();\n\n            Events.emit('autoplay');\n          }, this.time);\n        }\n      }\n    },\n\n    /**\n     * Stops autorunning of the glide.\n     *\n     * @return {Void}\n     */\n    stop: function stop() {\n      this._i = clearInterval(this._i);\n    },\n\n    /**\n     * Stops autoplaying while mouse is over glide's area.\n     *\n     * @return {Void}\n     */\n    bind: function bind() {\n      var _this2 = this;\n\n      Binder.on('mouseover', Components.Html.root, function () {\n        if (_this2._e) {\n          _this2.stop();\n        }\n      });\n      Binder.on('mouseout', Components.Html.root, function () {\n        if (_this2._e) {\n          _this2.start();\n        }\n      });\n    },\n\n    /**\n     * Unbind mouseover events.\n     *\n     * @returns {Void}\n     */\n    unbind: function unbind() {\n      Binder.off(['mouseover', 'mouseout'], Components.Html.root);\n    }\n  };\n  define(Autoplay, 'time', {\n    /**\n     * Gets time period value for the autoplay interval. Prioritizes\n     * times in `data-glide-autoplay` attrubutes over options.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      var autoplay = Components.Html.slides[Glide.index].getAttribute('data-glide-autoplay');\n\n      if (autoplay) {\n        return toInt(autoplay);\n      }\n\n      return toInt(Glide.settings.autoplay);\n    }\n  });\n  /**\n   * Stop autoplaying and unbind events:\n   * - on destroying, to clear defined interval\n   * - on updating via API to reset interval that may changed\n   */\n\n  Events.on(['destroy', 'update'], function () {\n    Autoplay.unbind();\n  });\n  /**\n   * Stop autoplaying:\n   * - before each run, to restart autoplaying\n   * - on pausing via API\n   * - on destroying, to clear defined interval\n   * - while starting a swipe\n   * - on updating via API to reset interval that may changed\n   */\n\n  Events.on(['run.before', 'swipe.start', 'update'], function () {\n    Autoplay.stop();\n  });\n  Events.on(['pause', 'destroy'], function () {\n    Autoplay.disable();\n    Autoplay.stop();\n  });\n  /**\n   * Start autoplaying:\n   * - after each run, to restart autoplaying\n   * - on playing via API\n   * - while ending a swipe\n   */\n\n  Events.on(['run.after', 'swipe.end'], function () {\n    Autoplay.start();\n  });\n  /**\n   * Start autoplaying:\n   * - after each run, to restart autoplaying\n   * - on playing via API\n   * - while ending a swipe\n   */\n\n  Events.on(['play'], function () {\n    Autoplay.enable();\n    Autoplay.start();\n  });\n  /**\n   * Remount autoplaying:\n   * - on updating via API to reset interval that may changed\n   */\n\n  Events.on('update', function () {\n    Autoplay.mount();\n  });\n  /**\n   * Destroy a binder:\n   * - on destroying glide instance to clearup listeners\n   */\n\n  Events.on('destroy', function () {\n    Binder.destroy();\n  });\n  return Autoplay;\n}\n\n/**\n * Sorts keys of breakpoint object so they will be ordered from lower to bigger.\n *\n * @param {Object} points\n * @returns {Object}\n */\n\nfunction sortBreakpoints(points) {\n  if (isObject(points)) {\n    return sortKeys(points);\n  } else {\n    warn(\"Breakpoints option must be an object\");\n  }\n\n  return {};\n}\n\nfunction Breakpoints (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  /**\n   * Holds reference to settings.\n   *\n   * @type {Object}\n   */\n\n  var settings = Glide.settings;\n  /**\n   * Holds reference to breakpoints object in settings. Sorts breakpoints\n   * from smaller to larger. It is required in order to proper\n   * matching currently active breakpoint settings.\n   *\n   * @type {Object}\n   */\n\n  var points = sortBreakpoints(settings.breakpoints);\n  /**\n   * Cache initial settings before overwritting.\n   *\n   * @type {Object}\n   */\n\n  var defaults = Object.assign({}, settings);\n  var Breakpoints = {\n    /**\n     * Matches settings for currectly matching media breakpoint.\n     *\n     * @param {Object} points\n     * @returns {Object}\n     */\n    match: function match(points) {\n      if (typeof window.matchMedia !== 'undefined') {\n        for (var point in points) {\n          if (points.hasOwnProperty(point)) {\n            if (window.matchMedia(\"(max-width: \".concat(point, \"px)\")).matches) {\n              return points[point];\n            }\n          }\n        }\n      }\n\n      return defaults;\n    }\n  };\n  /**\n   * Overwrite instance settings with currently matching breakpoint settings.\n   * This happens right after component initialization.\n   */\n\n  Object.assign(settings, Breakpoints.match(points));\n  /**\n   * Update glide with settings of matched brekpoint:\n   * - window resize to update slider\n   */\n\n  Binder.on('resize', window, throttle(function () {\n    Glide.settings = mergeOptions(settings, Breakpoints.match(points));\n  }, Glide.settings.throttle));\n  /**\n   * Resort and update default settings:\n   * - on reinit via API, so breakpoint matching will be performed with options\n   */\n\n  Events.on('update', function () {\n    points = sortBreakpoints(points);\n    defaults = Object.assign({}, settings);\n  });\n  /**\n   * Unbind resize listener:\n   * - on destroying, to bring markup to its initial state\n   */\n\n  Events.on('destroy', function () {\n    Binder.off('resize', window);\n  });\n  return Breakpoints;\n}\n\nvar COMPONENTS = {\n  // Required\n  Html: Html,\n  Translate: Translate,\n  Transition: Transition,\n  Direction: Direction,\n  Peek: Peek,\n  Sizes: Sizes,\n  Gaps: Gaps,\n  Move: Move,\n  Clones: Clones,\n  Resize: Resize,\n  Build: Build,\n  Run: Run,\n  // Optional\n  Swipe: Swipe,\n  Images: Images,\n  Anchors: Anchors,\n  Controls: Controls,\n  Keyboard: Keyboard,\n  Autoplay: Autoplay,\n  Breakpoints: Breakpoints\n};\n\nvar Glide = /*#__PURE__*/function (_Core) {\n  _inherits(Glide, _Core);\n\n  var _super = _createSuper(Glide);\n\n  function Glide() {\n    _classCallCheck(this, Glide);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Glide, [{\n    key: \"mount\",\n    value: function mount() {\n      var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return _get(_getPrototypeOf(Glide.prototype), \"mount\", this).call(this, Object.assign({}, COMPONENTS, extensions));\n    }\n  }]);\n\n  return Glide;\n}(Glide$1);\n\nexport { Glide as default };\n","/* Laura López Doval */\n\n// settings package sticky sidebar\n\nimport ResizeSensor from 'css-element-queries/src/ResizeSensor.js';\nimport StickySidebar from 'sticky-sidebar/src/sticky-sidebar.js';\n\nlet element = document.body;\nnew ResizeSensor(element, function() {\n    if (element.clientWidth >= 992) {\n\n        let sidebar = document.querySelectorAll('.sidebar');\n        sidebar.forEach(function(s) {\n            new StickySidebar(s, {\n                topSpacing: 125,\n                bottomSpacing: 20,\n                containerSelector: '.main-content',\n                innerWrapperSelector: '.sidebar__inner'\n            });\n        })\n    } \n});\n\n// document.addEventListener('DOMContentLoaded', function () {\n//     const bodyHasClassBio = document.body.classList.contains('bio-site');\n//     if ( bodyHasClassBio ) {\n        \n//         let element = document.body;\n//         new ResizeSensor(element, function() {\n//             if (element.clientWidth >= 992) {\n\n//                 let sidebar = document.querySelectorAll('.sidebar');\n//                 sidebar.forEach(function(s) {\n//                     new StickySidebar(s, {\n//                         topSpacing: 125,\n//                         bottomSpacing: 20,\n//                         containerSelector: '.main-content',\n//                         innerWrapperSelector: '.sidebar__inner'\n//                     });\n//                 })\n//             } \n//         });\n//     }\n// })\n\n// initialization slider\n\nimport Glide from '@glidejs/glide';\n\nconst bodyHasClassHome = document.body.classList.contains('home');\nconst bodyHasClassMuseum = document.body.classList.contains('museum-site');\n\nif ( bodyHasClassHome || bodyHasClassMuseum )  {\n    new Glide('.glide', {\n        type: 'slider',\n        startAt: 0,\n        autoplay: 4000\n    }).mount()\n}\n\n(function () {\n\n    // add active class navigation based on url\n\n    var current = location.pathname.split('/')[1];\n    var menuItems = document.querySelectorAll('.menu-item a');\n    \n    if (current === \"\") {\n        menuItems[0].classList.add('is-active')\n        return;\n    }\n    if (current === \"museum.html\") {\n        menuItems[1].classList.add('is-active')\n        return;\n    }\n    for (var i = 0, l = menuItems.length; i < l; i++) {\n        if (menuItems[i].getAttribute('href').indexOf(current) !== -1) {\n            menuItems[i].classList.add('is-active');\n        }\n    }\n})();\n\n(function () {\n    \n    // burger menu\n\n    let burger_menu = document.querySelector('.burger-menu');\n    let nav = document.querySelector('.nav');\n    let content = document.querySelector('.header-collapsed');\n\n    burger_menu.addEventListener('click', function() {\n        burger_menu.classList.toggle('change');\n        nav.classList.toggle('collapsed');\n        content.classList.toggle('top-to-header');\n    })\n\n})();\n\n"],"names":["factory","window","globalWindow","Math","self","Function","requestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","fn","setTimeout","cancelAnimationFrame","mozCancelAnimationFrame","webkitCancelAnimationFrame","timer","clearTimeout","forEachElement","elements","callback","elementsType","Object","prototype","toString","call","isCollectionTyped","jQuery","Elements","i","j","length","getElementSize","element","getBoundingClientRect","width","offsetWidth","height","offsetHeight","rect","round","setStyle","style","keys","forEach","key","ResizeSensor","lastAnimationFrameForInvisibleCheck","EventQueue","q","this","add","ev","push","sizeInfo","remove","newQueue","attachResizeEvent","resized","resizedAttached","resizeSensor","document","createElement","dir","className","pointerEvents","position","left","top","right","bottom","overflow","zIndex","visibility","maxWidth","styleChild","transition","expand","expandChild","appendChild","shrink","shrinkChild","computedStyle","getComputedStyle","getPropertyValue","dirty","rafId","size","lastWidth","lastHeight","initialHiddenCheck","reset","scrollLeft","scrollTop","resetSensor","onResized","onScroll","addEvent","el","name","cb","attachEvent","addEventListener","elem","detach","contains","removeChild","MutationObserver","observer","mutations","hasOwnProperty","items","addedNodes","event","observe","body","childList","subtree","define","amd","$e5ece0d8b05001a7$exports","$2ecfdc0296cfea99$var$StickySidebar","EVENT_KEY","DEFAULTS","topSpacing","bottomSpacing","StickySidebar","_setSupportFeatures","options","innerWrapperSelector","sidebarInner","sidebar","querySelector","wrapper","setAttribute","firstChild","containerSelector","containers","querySelectorAll","Array","slice","container","item","Error","parseInt","_widthBreakpoint","calcDimensions","stickyPosition","bindEvents","_initialized","passive","capture","handleEvent","updateSticky","_breakpoint","dims","dimensions","containerTop","offsetRelative","containerHeight","clientHeight","containerBottom","sidebarHeight","sidebarWidth","viewportHeight","innerHeight","_calcDimensionsWithScroll","sidebarLeft","documentElement","viewportTop","viewportLeft","affixedType","lastTopSpacing","translateY","_reStyle","lastBottomSpacing","lastViewportTop","furthest","direction","min","max","affixType","viewportBottom","colliderTop","isSidebarFitsViewport","sidebarBottom","colliderBottom","_getStyle","inner","outer","translate","_getTranslate","transform","extend","force","getAffixType","affixEvent","toLowerCase","replace","eventTrigger","removeClass","stickyClass","addClass","key1","_unit1","affixedEvent","innerWidth","minWidth","removeAttribute","_running","eventType","observeScrollDir","type","support","supportTransform","transform3d","y","x","z","removeEventListener","caption","classList","minHeight","styleReset","result","property","upper","charAt","toUpperCase","join","split","undefined","$511d2477bdce29e7$var$_typeof","obj","Symbol","iterator","constructor","$511d2477bdce29e7$var$_classCallCheck","instance","Constructor","TypeError","$511d2477bdce29e7$var$_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","$511d2477bdce29e7$var$_createClass","protoProps","staticProps","$511d2477bdce29e7$var$_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","$511d2477bdce29e7$var$_setPrototypeOf","p","$511d2477bdce29e7$var$_possibleConstructorReturn","ReferenceError","$511d2477bdce29e7$var$_assertThisInitialized","$511d2477bdce29e7$var$_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","e","$511d2477bdce29e7$var$_isNativeReflectConstruct","Super","NewTarget","arguments","apply","$511d2477bdce29e7$var$_superPropBase","object","$511d2477bdce29e7$var$_get","get","receiver","base","desc","getOwnPropertyDescriptor","value","$511d2477bdce29e7$var$defaults","startAt","perView","focusAt","gap","autoplay","hoverpause","keyboard","bound","swipeThreshold","dragThreshold","perSwipe","touchRatio","touchAngle","animationDuration","rewind","rewindDuration","animationTimingFunc","waitForTransition","throttle","peek","cloningRatio","breakpoints","classes","swipeable","dragging","ltr","rtl","slider","carousel","slide","clone","active","arrow","disabled","nav","$511d2477bdce29e7$var$warn","msg","console","error","concat","$511d2477bdce29e7$var$toInt","$511d2477bdce29e7$var$isString","$511d2477bdce29e7$var$isObject","$511d2477bdce29e7$var$isFunction","$511d2477bdce29e7$var$isUndefined","$511d2477bdce29e7$var$isArray","$511d2477bdce29e7$var$mount","glide","extensions","events","components","_name","mount","$511d2477bdce29e7$var$define","prop","definition","$511d2477bdce29e7$var$mergeOptions","defaults","settings","assign","$511d2477bdce29e7$var$EventsBus","EventsBus","hop","handler","index","on","context","emit","$511d2477bdce29e7$var$Glide$1","Glide","selector","_c","_t","_e","transformers","pattern","Run","make","distance","Transition","disable","Move","interval","_o","set","_i","_d","$511d2477bdce29e7$var$throttle","func","wait","timeout","args","previous","later","leading","$511d2477bdce29e7$var$now","at","remaining","trailing","cancel","throttled","$511d2477bdce29e7$var$MARGIN_TYPE","n","nextSibling","nodeType","node","matched","$511d2477bdce29e7$var$exist","HTMLElement","$511d2477bdce29e7$var$toArray","nodeList","listeners","EventsBinder","closure","$511d2477bdce29e7$var$VALID_DIRECTIONS","$511d2477bdce29e7$var$Rtl","Components","$511d2477bdce29e7$var$Gap","Gaps","multiplier","$511d2477bdce29e7$var$Grow","Clones","grow","modify","$511d2477bdce29e7$var$Focusing","slideWidth","$511d2477bdce29e7$var$supportsPassive","$511d2477bdce29e7$var$opts","$511d2477bdce29e7$var$supportsPassive$1","$511d2477bdce29e7$var$START_EVENTS","$511d2477bdce29e7$var$MOVE_EVENTS","$511d2477bdce29e7$var$END_EVENTS","$511d2477bdce29e7$var$PREVIOUS_CONTROLS_SELECTOR","$511d2477bdce29e7$var$CONTROLS_SELECTOR","$511d2477bdce29e7$var$NEXT_CONTROLS_SELECTOR","$511d2477bdce29e7$var$sortBreakpoints","points","sort","reduce","r","k","$511d2477bdce29e7$var$COMPONENTS","Html","Events","root","track","$511d2477bdce29e7$var$TRACK_SELECTOR","collectSlides","slides","children","filter","_r","t","Translate","mutate","TRANSFORMERS","transformer","$511d2477bdce29e7$var$mutator","translate3d","mozTransform","webkitTransform","getStartIndex","Sizes","isOffset","travelDistance","after","startWidth","getTravelDistance","compose","duration","isType","offset","enable","Direction","resolve","token","is","$511d2477bdce29e7$var$FLIPED_MOVEMENTS","_v","indexOf","Peek","before","wrapperSize","reductor","setupSlides","setupWrapper","marginLeft","marginRight","_this","movement","collect","_Glide$settings","peekIncrementer","cloneCount","reverse","floor","append","cloneNode","unshift","_clone","half","_i2","prepend","insertBefore","_i3","Resize","bind","Binder","unbind","off","destroy","Build","typeClass","activeClass","$511d2477bdce29e7$var$siblings","sibling","removeClasses","move","calculate","isStart","isEnd","steps","viewSize","calculateForwardIndex","isBound","normalizeForwardIndex","ceil","_index","normalizeBackwardIndex","_m","step","Swipe","swipeStartY","bindSwipeStart","swipe","pageY","bindSwipeMove","bindSwipeEnd","touches","subExSx","pageX","swipeStartX","subEySy","powEX","abs","powEY","swipeHypotenuse","sqrt","swipeCathetus","parseFloat","_Glide$settings2","threshold","swipeDistance","swipeDeg","swipeSin","PI","unbindSwipeMove","unbindSwipeEnd","start","_this2","_this3","end","$511d2477bdce29e7$var$MOUSE_EVENTS","changedTouches","Images","dragstart","preventDefault","_a","click","prevented","stopPropagation","detached","draggable","attach","Anchors","$511d2477bdce29e7$var$EventsBinder","_arrowControls","next","setActive","_n","controls","Controls","resetArrowState","disableArrow","lists","list","addBindings","currentTarget","getAttribute","setArrowState","removeActive","Keyboard","press","code","Autoplay","time","clearInterval","stop","point","matchMedia","matches","Breakpoints","match","_Core","subClass","superClass","create","_super","$7e6258f3559d0f34$var$element","$parcel$interopDefault","clientWidth","s","$2ecfdc0296cfea99$export$2e2bcd8739ae039","$7e6258f3559d0f34$var$bodyHasClassHome","$7e6258f3559d0f34$var$bodyHasClassMuseum","$511d2477bdce29e7$export$2e2bcd8739ae039","current","location","pathname","menuItems","l","burger_menu","content","toggle"],"version":3,"file":"index.39af3259.js.map"}